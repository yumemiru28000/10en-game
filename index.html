<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円ゲーム マップ＆レバー実験 v1拡張</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }

    #uiPanel {
      width: 260px;
      background: #111;
      border-right: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }

    #leverArea {
      position: relative;
      width: 220px;
      height: 140px;
      margin: 0 auto;
      border: 1px solid #444;
      background: #181818;
      border-radius: 4px;
      touch-action: none;
    }

    #lever {
      position: absolute;
      width: 12px;
      height: 80px;
      background: #ccc;
      left: 50%;
      bottom: 15px;
      transform-origin: 50% 100%;
      transform: translateX(-50%) rotate(0deg);
      cursor: grab;
    }
    #lever:active {
      cursor: grabbing;
    }
    #lever::after {
      content: "";
      position: absolute;
      width: 30px;
      height: 12px;
      background: #ccc;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
    }
    #leverLabel {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      color: #aaa;
    }

    #leverInfo {
      font-size: 12px;
      line-height: 1.5;
    }

    #world {
      flex: 1;
      position: relative;
    }

    #world canvas {
      display: block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center center;
    }

    button {
      font-size: 12px;
      padding: 4px 8px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 4px;
    }
    button:hover {
      background: #444;
    }
    input[type="number"],
    input[type="password"],
    input[type="text"] {
      width: 80px;
      background: #222;
      border: 1px solid #555;
      color: #eee;
      padding: 2px 4px;
      border-radius: 3px;
      margin-bottom: 4px;
    }

    #adminPanel {
      border-top: 1px solid #333;
      padding-top: 6px;
      margin-top: 6px;
      font-size: 11px;
    }
    #adminPanel.disabled {
      opacity: 0.4;
    }

    #adminStatus {
      font-size: 11px;
      color: #ccc;
      margin-bottom: 4px;
    }

    #stickInfo {
      font-size: 11px;
      color: #aaa;
    }
    #stickThickness {
      width: 100%;
    }

    .admin-only {
      display: none;
    }
    .admin-visible {
      display: block;
    }

    fieldset {
      border: 1px solid #444;
      margin-bottom: 6px;
      padding: 4px;
    }
    legend {
      font-size: 11px;
      padding: 0 4px;
      color: #ccc;
    }
    label {
      display: inline-block;
      min-width: 70px;
    }
  </style>
</head>
<body>
  <div id="uiPanel">
    <!-- レバー UI -->
    <div id="leverArea">
      <div id="lever"></div>
      <div id="leverLabel">レバー</div>
    </div>
    <div id="leverInfo">
      角度: <span id="angleText">0</span>°<br>
      引き具合(0～1): <span id="powerText">0.00</span>
    </div>

    <!-- 一般設定 -->
    <div>
      重力:
      <input id="gravity" type="number" step="0.1" value="9.8">
      <br>
      <button id="addCoin">10円を置く</button>
      <button id="resetWorld">10円リセット</button>
    </div>

    <!-- 運営モード（ここだけ常に表示。中身は後で制御） -->
    <div id="adminPanel" class="disabled">
      <div><strong>運営モード</strong></div>
      <div id="adminStatus">未ログイン</div>
      パスワード:
      <input id="adminPass" type="password" placeholder="1122">
      <button id="adminLogin">ログイン</button>

      <!-- ここ以下は運営にのみ表示 -->
      <div id="adminInner" class="admin-only">
        <!-- レバー＆スポーン管理 -->
        <fieldset>
          <legend>レバー / スポーン設定</legend>
          <div>
            <label>レバー番号</label>
            <select id="leverIndexSelect"></select>
            <button id="addLeverConfig">追加</button>
          </div>
          <div>
            <label>スポーンX</label>
            <input id="spawnX" type="number">
            <label>Y</label>
            <input id="spawnY" type="number">
          </div>
          <div>
            <label>レバーX</label>
            <input id="leverX" type="number">
            <label>Y</label>
            <input id="leverY" type="number">
          </div>
          <div>
            <label>方向(°)</label>
            <input id="launchDeg" type="number">
          </div>
          <div>
            <label>最大強さ</label>
            <input id="launchPower" type="number">
          </div>
          <div>
            <button id="applyLeverConfig">設定を適用</button>
          </div>
          <div>
            <button id="resetLeverPos">レバー位置リセット</button>
            <button id="resetSpawnPos">スポーン位置リセット</button>
          </div>
        </fieldset>

        <!-- 棒編集 -->
        <fieldset>
          <legend>棒編集</legend>
          <button id="toggleStickEdit">棒編集モード: OFF</button><br>
          棒の太さ:
          <input id="stickThickness" type="range" min="5" max="50" value="20">
          <span id="stickThicknessLabel">20</span> px<br>
          <button id="resetSticks">棒 全リセット</button>
          <div id="stickInfo">
            棒編集モード中: キャンバス上を2回クリックすると<br>
            その2点をつなぐ棒ができます。
          </div>
        </fieldset>
      </div>
    </div>
  </div>

  <div id="world"></div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ============================================================
    // 設定用定数（v1ベース）
    // ============================================================
    const REBA_HEAVINESS_EXPONENT = 3.0;   // 引くほど重く（非線形）
    const REBA_MAX_ANGLE_DEG      = 90;
    const REBA_DRAG_SENSITIVITY   = 0.5;
    const REBA_LAUNCH_RADIUS      = 30;

    // 10円（5.5g）: 斜面でよく転がるように v1 っぽい摩擦
    const COIN_RADIUS = 11;
    const COIN_MASS   = 0.0055;
    const COIN_FRICTION        = 0.01;   // 動摩擦かなり小さい
    const COIN_FRICTION_STATIC = 0.03;   // 静止摩擦も低め
    const COIN_FRICTION_AIR    = 0.0003; // 空気抵抗少なめ
    const COIN_RESTITUTION     = 0.2;

    // デフォルトのレバー＆スポーン
    const DEFAULT_LEVER_CONFIG = {
      spawnX: 260,
      spawnY: 320,
      leverX: 260,
      leverY: 120,   // 画面上のレバーアイコン表示用（世界座標とは独立した UI だが、管理用に保存）
      launchDeg: -45,
      maxPower: 35
    };

    // マップ画像
    const MAP_IMAGE_URL = "https://raw.githubusercontent.com/yumemiru28000/10en-game/main/map.png";

    // ============================================================
    // Matter.js セットアップ
    // ============================================================
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const Runner = Matter.Runner;
    const Bodies = Matter.Bodies;
    const Composite = Matter.Composite;
    const Body = Matter.Body;
    const Mouse = Matter.Mouse;
    const MouseConstraint = Matter.MouseConstraint;

    const engine = Engine.create();
    const world  = engine.world;
    engine.world.gravity.y = 9.8; // 地球の重力に近い値

    const canvasWidth  = window.innerWidth - 260; // UIパネル分
    const canvasHeight = window.innerHeight;

    const render = Render.create({
      element: document.getElementById('world'),
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: '#000'
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    render.canvas.style.backgroundImage = `url("${MAP_IMAGE_URL}")`;
    render.canvas.style.backgroundSize = "contain";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "center center";

    // ============================================================
    // 壁・フィールド
    // ============================================================
    const thickness = 40;
    const leftWall = Bodies.rectangle(20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const rightWall = Bodies.rectangle(canvasWidth - 20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const ceiling = Bodies.rectangle(canvasWidth / 2, 20, canvasWidth, thickness, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });

    // 右下 大きめ斜面
    const floorAngle = -Math.PI / 8;
    const floorLength = 500;
    const slopedFloor = Bodies.rectangle(
      canvasWidth - 260,
      canvasHeight - 60,
      floorLength,
      20,
      {
        isStatic: true,
        angle: floorAngle,
        friction: 0.02,
        frictionStatic: 0.05,
        render: { fillStyle: "rgba(120,120,120,0.7)" }
      }
    );

    const cornerPost = Bodies.rectangle(
      canvasWidth - 350,
      canvasHeight - 150,
      20,
      80,
      {
        isStatic: true,
        friction: 0.2,
        render: { fillStyle: "rgba(160,160,160,0.7)" }
      }
    );

    // わずかな斜面 (テスト用)
    const gentleSlope = Bodies.rectangle(
      canvasWidth / 2,
      canvasHeight / 2 + 80,
      350,
      10,
      {
        isStatic: true,
        angle: 0.04,
        friction: 0.01,
        frictionStatic: 0.02,
        render: { fillStyle: "rgba(100,100,100,0.7)" }
      }
    );

    Composite.add(world, [leftWall, rightWall, ceiling, slopedFloor, cornerPost, gentleSlope]);

    // ============================================================
    // 棒（線分）編集機能（運営モード）
    // ============================================================
    const stickBodies = [];
    let isAdmin = false;
    let stickEditMode = false;
    let pendingPoint = null;
    const adminPanelEl = document.getElementById("adminPanel");
    const adminStatusEl = document.getElementById("adminStatus");
    const adminPassEl   = document.getElementById("adminPass");
    const adminLoginBtn = document.getElementById("adminLogin");
    const toggleStickEditBtn = document.getElementById("toggleStickEdit");
    const resetSticksBtn     = document.getElementById("resetSticks");
    const stickThicknessInput= document.getElementById("stickThickness");
    const stickThicknessLabel= document.getElementById("stickThicknessLabel");
    const adminInnerEl       = document.getElementById("adminInner");

    let currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;
    stickThicknessLabel.textContent = currentStickThickness;

    stickThicknessInput.addEventListener("input", () => {
      currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;
      stickThicknessLabel.textContent = currentStickThickness;
    });

    adminLoginBtn.addEventListener("click", () => {
      if (adminPassEl.value === "1122") {
        isAdmin = true;
        adminStatusEl.textContent = "ログイン中（運営モード）";
        adminPanelEl.classList.remove("disabled");
        adminInnerEl.classList.remove("admin-only");
        adminInnerEl.classList.add("admin-visible");
      } else {
        isAdmin = false;
        adminStatusEl.textContent = "パスワード不正";
        adminInnerEl.classList.add("admin-only");
        adminInnerEl.classList.remove("admin-visible");
      }
    });

    toggleStickEditBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      stickEditMode = !stickEditMode;
      toggleStickEditBtn.textContent = "棒編集モード: " + (stickEditMode ? "ON" : "OFF");
      if (!stickEditMode) pendingPoint = null;
    });

    resetSticksBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      for (const b of stickBodies) Composite.remove(world, b);
      stickBodies.length = 0;
      pendingPoint = null;
    });

    // canvas クリックで棒を追加
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: {
        stiffness: 0.1,
        render: { visible: false }
      }
    });
    Composite.add(world, mouseConstraint);
    render.mouse = mouse;

    render.canvas.addEventListener("mousedown", (e) => {
      if (!isAdmin || !stickEditMode) return;
      const rect = render.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (!pendingPoint) {
        pendingPoint = { x, y };
      } else {
        const x1 = pendingPoint.x;
        const y1 = pendingPoint.y;
        const x2 = x;
        const y2 = y;
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const stick = Bodies.rectangle(
          cx,
          cy,
          length,
          currentStickThickness,
          {
            isStatic: true,
            angle: angle,
            friction: 0.02,
            frictionStatic: 0.05,
            render: { fillStyle: "rgba(180,180,180,0.8)" }
          }
        );
        Composite.add(world, stick);
        stickBodies.push(stick);
        pendingPoint = null;
      }
    });

    // ============================================================
    // 10円玉
    // ============================================================
    const coins = [];

    function createCoin(x, y) {
      return Bodies.circle(x, y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: COIN_RESTITUTION,
        friction: COIN_FRICTION,
        frictionStatic: COIN_FRICTION_STATIC,
        frictionAir: COIN_FRICTION_AIR,
        render: {
          fillStyle: "#cc8844",
          strokeStyle: "#ddbb77",
          lineWidth: 2
        }
      });
    }
    function addCoinAt(x, y) {
      const c = createCoin(x, y);
      coins.push(c);
      Composite.add(world, c);
      return c;
    }

    // ============================================================
    // レバー＆スポーン 複数管理
    // ============================================================
    // leverConfigs[ index ] = { spawnX, spawnY, leverX, leverY, launchDeg, maxPower }
    const leverConfigs = [];
    leverConfigs.push({ ...DEFAULT_LEVER_CONFIG });
    let currentLeverIndex = 0;

    const leverIndexSelect = document.getElementById("leverIndexSelect");
    const addLeverConfigBtn = document.getElementById("addLeverConfig");
    const spawnXInput = document.getElementById("spawnX");
    const spawnYInput = document.getElementById("spawnY");
    const leverXInput = document.getElementById("leverX");
    const leverYInput = document.getElementById("leverY");
    const launchDegInput = document.getElementById("launchDeg");
    const launchPowerInput = document.getElementById("launchPower");
    const applyLeverConfigBtn = document.getElementById("applyLeverConfig");
    const resetLeverPosBtn = document.getElementById("resetLeverPos");
    const resetSpawnPosBtn = document.getElementById("resetSpawnPos");

    function refreshLeverIndexSelect() {
      leverIndexSelect.innerHTML = "";
      leverConfigs.forEach((cfg, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = (i + 1) + "番";
        leverIndexSelect.appendChild(opt);
      });
      leverIndexSelect.value = currentLeverIndex;
    }
    function loadLeverConfigToInputs() {
      const cfg = leverConfigs[currentLeverIndex];
      spawnXInput.value = cfg.spawnX;
      spawnYInput.value = cfg.spawnY;
      leverXInput.value = cfg.leverX;
      leverYInput.value = cfg.leverY;
      launchDegInput.value = cfg.launchDeg;
      launchPowerInput.value = cfg.maxPower;
    }

    leverIndexSelect.addEventListener("change", () => {
      currentLeverIndex = parseInt(leverIndexSelect.value, 10) || 0;
      loadLeverConfigToInputs();
      drawLaunchArea();
    });

    addLeverConfigBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      leverConfigs.push({ ...DEFAULT_LEVER_CONFIG });
      currentLeverIndex = leverConfigs.length - 1;
      refreshLeverIndexSelect();
      loadLeverConfigToInputs();
      drawLaunchArea();
    });

    applyLeverConfigBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      const cfg = leverConfigs[currentLeverIndex];
      cfg.spawnX = parseFloat(spawnXInput.value) || cfg.spawnX;
      cfg.spawnY = parseFloat(spawnYInput.value) || cfg.spawnY;
      cfg.leverX = parseFloat(leverXInput.value) || cfg.leverX;
      cfg.leverY = parseFloat(leverYInput.value) || cfg.leverY;
      cfg.launchDeg = parseFloat(launchDegInput.value) || cfg.launchDeg;
      cfg.maxPower = parseFloat(launchPowerInput.value) || cfg.maxPower;
      drawLaunchArea();
    });

    resetLeverPosBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      const cfg = leverConfigs[currentLeverIndex];
      cfg.leverX = DEFAULT_LEVER_CONFIG.leverX;
      cfg.leverY = DEFAULT_LEVER_CONFIG.leverY;
      loadLeverConfigToInputs();
      drawLaunchArea();
    });

    resetSpawnPosBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      const cfg = leverConfigs[currentLeverIndex];
      cfg.spawnX = DEFAULT_LEVER_CONFIG.spawnX;
      cfg.spawnY = DEFAULT_LEVER_CONFIG.spawnY;
      loadLeverConfigToInputs();
      drawLaunchArea();
    });

    refreshLeverIndexSelect();
    loadLeverConfigToInputs();

    // 初期状態で、1番レバーのスポーン位置に10円を1個
    addCoinAt(leverConfigs[0].spawnX, leverConfigs[0].spawnY);

    // 発射台の見た目（スリット）は「現行レバー1番」の位置に合わせる
    function createLaunchSlotBodies(cfg) {
      const blockThickness = 20;
      const baseBlockWidth = 80;
      const upper = Bodies.rectangle(
        cfg.spawnX,
        cfg.spawnY - COIN_RADIUS - 5,
        baseBlockWidth,
        blockThickness,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      const lower = Bodies.rectangle(
        cfg.spawnX,
        cfg.spawnY + COIN_RADIUS + 5,
        baseBlockWidth,
        blockThickness,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      const left = Bodies.rectangle(
        cfg.spawnX - baseBlockWidth / 2 + 10,
        cfg.spawnY,
        20,
        COIN_RADIUS * 4,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      return [upper, lower, left];
    }
    const slotBodies = createLaunchSlotBodies(leverConfigs[0]);
    Composite.add(world, slotBodies);

    // ============================================================
    // レバー UI ロジック（単一レバーUIだが、パワーは「現在選択中レバー」の設定を使用）
    // ============================================================
    const leverEl = document.getElementById("lever");
    const angleTextEl = document.getElementById("angleText");
    const powerTextEl = document.getElementById("powerText");
    const gravityInput = document.getElementById("gravity");
    const addCoinBtn = document.getElementById("addCoin");
    const resetWorldBtn = document.getElementById("resetWorld");

    let leverAngleDeg = 0;
    let isDraggingLever = false;
    let dragStartY = 0;
    let dragStartAngle = 0;

    function calcPullPower() {
      const normalized = leverAngleDeg / REBA_MAX_ANGLE_DEG;
      return Math.pow(normalized, REBA_HEAVINESS_EXPONENT);
    }
    function updateLeverVisual() {
      leverEl.style.transform = `translateX(-50%) rotate(${leverAngleDeg}deg)`;
      angleTextEl.textContent = leverAngleDeg.toFixed(1);
      powerTextEl.textContent = calcPullPower().toFixed(2);
    }

    function getLaunchDirection(cfg) {
      const rad = cfg.launchDeg * Math.PI / 180;
      return { x: Math.cos(rad), y: Math.sin(rad) };
    }
    function getLaunchPower(cfg) {
      return calcPullPower() * cfg.maxPower;
    }

    function releaseLeverAndLaunch() {
      const cfg = leverConfigs[currentLeverIndex];
      const power = getLaunchPower(cfg);
      if (power <= 0.1) {
        leverAngleDeg = 0;
        updateLeverVisual();
        return;
      }
      const dir = getLaunchDirection(cfg);
      coins.forEach(c => {
        const dx = c.position.x - cfg.spawnX;
        const dy = c.position.y - cfg.spawnY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < REBA_LAUNCH_RADIUS) {
          const vx = dir.x * power;
          const vy = dir.y * power;
          Body.setVelocity(c, { x: vx, y: vy });
        }
      });
      leverAngleDeg = 0;
      updateLeverVisual();
    }

    function startDragLever(y) {
      isDraggingLever = true;
      dragStartY = y;
      dragStartAngle = leverAngleDeg;
    }
    function moveDragLever(y) {
      if (!isDraggingLever) return;
      const dy = y - dragStartY;
      let newAngle = dragStartAngle + dy * REBA_DRAG_SENSITIVITY;
      newAngle = Math.max(0, Math.min(REBA_MAX_ANGLE_DEG, newAngle));
      leverAngleDeg = newAngle;
      updateLeverVisual();
    }
    function endDragLever() {
      if (!isDraggingLever) return;
      isDraggingLever = false;
      releaseLeverAndLaunch();
    }

    leverEl.addEventListener("mousedown", e => {
      e.preventDefault();
      startDragLever(e.clientY);
    });
    window.addEventListener("mousemove", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      moveDragLever(e.clientY);
    });
    window.addEventListener("mouseup", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    });

    leverEl.addEventListener("touchstart", e => {
      e.preventDefault();
      const t = e.touches[0];
      startDragLever(t.clientY);
    }, { passive: false });
    window.addEventListener("touchmove", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      const t = e.touches[0];
      moveDragLever(t.clientY);
    }, { passive: false });
    window.addEventListener("touchend", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    }, { passive: false });

    updateLeverVisual();

    // ============================================================
    // 「飛ばす範囲」を緑円で表示
    // ============================================================
    function drawLaunchArea() {
      const ctx = render.context;
      if (!ctx) return;
      // Matter.js が描画する前にフックして描くのが本当は良いが、
      // 手軽にするため requestAnimationFrame で上書きしていく。
    }
    // Matter.Render には beforeRender / afterRender が無いので、
    // 独自に overlay を描く（簡易版）
    (function renderOverlay() {
      requestAnimationFrame(renderOverlay);
      const ctx = render.context;
      if (!ctx) return;
      ctx.save();
      // 既にMatter.jsが描いた後に上書きするので、単に円を描く
      const cfg = leverConfigs[currentLeverIndex];
      ctx.beginPath();
      ctx.strokeStyle = "rgba(0,255,0,0.5)";
      ctx.lineWidth = 2;
      ctx.arc(cfg.spawnX, cfg.spawnY, REBA_LAUNCH_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    })();

    // ============================================================
    // UI ボタン
    // ============================================================
    gravityInput.addEventListener("input", e => {
      const g = parseFloat(e.target.value) || 0;
      engine.world.gravity.y = g;
    });

    addCoinBtn.addEventListener("click", () => {
      const cfg = leverConfigs[currentLeverIndex];
      const x = cfg.spawnX + (Math.random() * 20 - 10);
      const y = cfg.spawnY + (Math.random() * 10 - 5);
      addCoinAt(x, y);
    });

    resetWorldBtn.addEventListener("click", () => {
      coins.forEach(c => Composite.remove(world, c));
      coins.length = 0;
      leverConfigs.forEach(cfg => {
        addCoinAt(cfg.spawnX, cfg.spawnY);
      });
      leverAngleDeg = 0;
      updateLeverVisual();
    });
  </script>
</body>
</html>
