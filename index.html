<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>10円 vs 坂1本 物理テスト</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
    }
    #info {
      font-size: 12px;
      margin-bottom: 4px;
    }
    #canvasWrapper {
      position: relative;
      border: 1px solid #555;
      background: #000;
    }
    #controlPanel {
      font-size: 12px;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div id="info">
    左クリック2回で坂の始点・終点を指定 → 「10円リセット」で坂の上に乗せる → 再生<br>
    坂の角度に応じて自然に転がり、緩ければ止まるように調整済み。
  </div>
  <div id="canvasWrapper">
    <canvas id="gameCanvas" width="600" height="400"></canvas>
  </div>
  <div id="controlPanel">
    重力: <input id="gravityInput" type="number" step="0.1" value="0.5">
    摩擦: <input id="frictionInput" type="number" step="0.01" value="0.02">
    静止閾値: <input id="staticInput" type="number" step="0.01" value="0.02">
    <button id="resetCoinBtn">10円リセット</button>
    <button id="playPauseBtn">一時停止</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gravityInput = document.getElementById("gravityInput");
    const frictionInput = document.getElementById("frictionInput");
    const staticInput = document.getElementById("staticInput");
    const resetCoinBtn = document.getElementById("resetCoinBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");

    let GRAVITY = parseFloat(gravityInput.value) || 0.5; // 下向き重力（px/frame^2）
    let SLOPE_FRICTION = parseFloat(frictionInput.value) || 0.02; // 坂上摩擦（動摩擦）
    let STATIC_THRESHOLD = parseFloat(staticInput.value) || 0.02; // 静止摩擦閾値（加速度）

    gravityInput.addEventListener("input", () => {
      GRAVITY = parseFloat(gravityInput.value) || GRAVITY;
    });
    frictionInput.addEventListener("input", () => {
      SLOPE_FRICTION = parseFloat(frictionInput.value) || SLOPE_FRICTION;
    });
    staticInput.addEventListener("input", () => {
      STATIC_THRESHOLD = parseFloat(staticInput.value) || STATIC_THRESHOLD;
    });

    const coin = {
      x: canvas.width/2,
      y: 50,
      vx: 0,
      vy: 0,
      r: 12
    };

    // 坂1本（線分）
    let slope = {
      hasSlope: false,
      x1: 100, y1: 300,
      x2: 500, y2: 250
    };

    // クリックで坂の始点・終点を指定
    let slopeClickStage = 0;
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (slopeClickStage === 0) {
        slope.x1 = x; slope.y1 = y;
        slopeClickStage = 1;
      } else {
        slope.x2 = x; slope.y2 = y;
        slope.hasSlope = true;
        slopeClickStage = 0;
      }
    });

    // コインを坂の上にリセット
    resetCoinBtn.addEventListener("click", () => {
      if (!slope.hasSlope) {
        coin.x = canvas.width/2;
        coin.y = 50;
      } else {
        // 坂の中点に置く + 少し上にオフセット
        const mx = (slope.x1 + slope.x2)/2;
        const my = (slope.y1 + slope.y2)/2;
        const dx = slope.x2 - slope.x1;
        const dy = slope.y2 - slope.y1;
        const len = Math.sqrt(dx*dx + dy*dy) || 1;
        const nx = -(dy/len); // 法線（上向き寄り）
        const ny =  (dx/len);
        coin.x = mx + nx * coin.r;
        coin.y = my + ny * coin.r;
      }
      coin.vx = 0;
      coin.vy = 0;
    });

    let paused = false;
    playPauseBtn.addEventListener("click", () => {
      paused = !paused;
      playPauseBtn.textContent = paused ? "再生" : "一時停止";
    });

    // 距離判定用：点 C と線分 AB の最近点 P と距離 d を返す
    function closestPointOnSegment(ax, ay, bx, by, cx, cy) {
      const abx = bx - ax;
      const aby = by - ay;
      const acx = cx - ax;
      const acy = cy - ay;
      const abLen2 = abx*abx + aby*aby || 1;
      let t = (acx * abx + acy * aby) / abLen2;
      t = Math.max(0, Math.min(1, t));
      const px = ax + abx * t;
      const py = ay + aby * t;
      const dx = cx - px;
      const dy = cy - py;
      const d = Math.sqrt(dx*dx + dy*dy);
      return { px, py, d };
    }

    function updatePhysics() {
      if (paused) return;

      // 1. 重力で加速
      coin.vy += GRAVITY;

      // 2. 位置更新（まずは自由落下）
      const prevX = coin.x;
      const prevY = coin.y;
      coin.x += coin.vx;
      coin.y += coin.vy;

      if (slope.hasSlope) {
        // 3. 円 vs 坂線分 の距離を計���
        const { px, py, d } = closestPointOnSegment(
          slope.x1, slope.y1, slope.x2, slope.y2,
          coin.x, coin.y
        );

        if (d < coin.r) {
          // 衝突中：坂の法線と接線（単位ベクトル）を計算
          const dx = slope.x2 - slope.x1;
          const dy = slope.y2 - slope.y1;
          const len = Math.sqrt(dx*dx + dy*dy) || 1;
          const tx = dx / len;       // 接線（坂に沿う方向, 右向き）
          const ty = dy / len;
          const nx = -(ty);          // 法線（坂の外側：ここでは「上側」を想定）
          const ny =  (tx);

          // 円を坂の外側に押し出す（MTD）
          const penetration = coin.r - d;
          coin.x += nx * penetration;
          coin.y += ny * penetration;

          // 速度を接線/法線に分解
          const vpx = coin.vx;
          const vpy = coin.vy;
          const v_parallel = vpx * tx + vpy * ty;  // 接線成分（スカラー）
          let v_normal   = vpx * nx + vpy * ny;    // 法線成分（スカラー）

          // 法線方向速度は坂が受け止める：0 に近づける
          v_normal = 0;

          // 接線方向の重力加速度 a_parallel = g・t
          const g_parallel = GRAVITY * ty; // g=(0,GRAVITY) なので dot(g,t) = GRAVITY*ty
          let new_v_parallel = v_parallel + g_parallel;

          // 静止摩擦：加速度と速度が小さいなら止める
          if (Math.abs(g_parallel) < STATIC_THRESHOLD && Math.abs(v_parallel) < STATIC_THRESHOLD) {
            new_v_parallel = 0;
          } else {
            // 動摩擦：少し減衰
            new_v_parallel *= (1 - SLOPE_FRICTION);
          }

          // 接線＋法線に戻す
          coin.vx = new_v_parallel * tx + v_normal * nx;
          coin.vy = new_v_parallel * ty + v_normal * ny;
        }
      }

      // 4. 画面の枠でバウンド（テスト用）
      const bounce = 0.3;
      if (coin.x - coin.r < 0) {
        coin.x = coin.r;
        coin.vx *= -bounce;
      }
      if (coin.x + coin.r > canvas.width) {
        coin.x = canvas.width - coin.r;
        coin.vx *= -bounce;
      }
      if (coin.y - coin.r < 0) {
        coin.y = coin.r;
        coin.vy *= -bounce;
      }
      if (coin.y + coin.r > canvas.height) {
        coin.y = canvas.height - coin.r;
        coin.vy *= -bounce;
      }
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // 坂
      if (slope.hasSlope || slopeClickStage === 1) {
        ctx.strokeStyle = "#44aaff";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(slope.x1, slope.y1);
        ctx.lineTo(slope.x2, slope.y2);
        ctx.stroke();
      }

      // 円
      ctx.save();
      ctx.translate(coin.x, coin.y);
      ctx.fillStyle = "#cc8844";
      ctx.beginPath();
      ctx.arc(0,0,coin.r,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#5b3a10";
      ctx.font = "bold 10px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("10",0,0);
      ctx.restore();

      // デバッグ用：速度ベクトル
      ctx.strokeStyle = "#ff00ff";
      ctx.beginPath();
      ctx.moveTo(coin.x, coin.y);
      ctx.lineTo(coin.x + coin.vx * 3, coin.y + coin.vy * 3);
      ctx.stroke();
    }

    function loop() {
      requestAnimationFrame(loop);
      updatePhysics();
      draw();
    }

    loop();
  </script>
</body>
</html>
