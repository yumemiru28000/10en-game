<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円玉 発射レバー 実験</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #world {
      flex: 1;
    }
    #ui {
      padding: 8px;
      background: #111;
      font-size: 14px;
    }
    button {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div id="world"></div>
  <div id="ui">
    マウスでレバー（白い棒）をドラッグして「引き」、離すと 10円が発射されます。
    <button id="reset">リセット</button>
  </div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    const {
      Engine,
      Render,
      Runner,
      Bodies,
      Composite,
      Constraint,
      Body,
      Mouse,
      MouseConstraint,
      Vector,
      Events
    } = Matter;

    const engine = Engine.create();
    const world  = engine.world;

    // 重力（下向き）
    engine.world.gravity.y = 1;

    const width  = 800;
    const height = 400;

    const render = Render.create({
      element: document.getElementById('world'),
      engine,
      options: {
        width,
        height,
        wireframes: false,
        background: '#222'
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // 床と壁
    const floor = Bodies.rectangle(width/2, height-20, width, 40, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });

    const leftWall = Bodies.rectangle(40, height/2, 40, height, {
      isStatic: true,
      render: { fillStyle: '#333' }
    });
    const rightWall = Bodies.rectangle(width-40, height/2, 40, height, {
      isStatic: true,
      render: { fillStyle: '#333' }
    });

    Composite.add(world, [floor, leftWall, rightWall]);

    // 10円玉パラメータ
    const COIN_RADIUS = 11;      // 見た目の大きさ
    const COIN_MASS   = 0.0055;  // 5.5g

    // 発射位置（レバー先端の前あたり）
    const LAUNCH_X = 250;
    const LAUNCH_Y = height - 80;

    function createCoin() {
      const coin = Bodies.circle(LAUNCH_X, LAUNCH_Y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: 0.3,
        friction: 0.05,
        frictionAir: 0.001,
        render: {
          fillStyle: '#cc8844',
          strokeStyle: '#ddbb77',
          lineWidth: 2
        }
      });
      return coin;
    }

    let coin = createCoin();
    Composite.add(world, coin);

    // レバー（打ち出し棒）
    // 支点は少し左下、棒は右方向に伸びる
    const PIVOT_X = 200;
    const PIVOT_Y = height - 60;
    const LEVER_LENGTH = 150;

    const lever = Bodies.rectangle(
      PIVOT_X + LEVER_LENGTH/2,
      PIVOT_Y,
      LEVER_LENGTH,
      18,
      {
        mass: 1,
        friction: 0.02,
        frictionAir: 0.002,
        render: {
          fillStyle: '#f0f0f0'
        }
      }
    );

    // 支点（固定）
    const pivot = Bodies.circle(PIVOT_X, PIVOT_Y, 5, {
      isStatic: true,
      render: { fillStyle: '#ff4444' }
    });

    // レバーと支点を結ぶジョイント（回転ヒンジ）
    const hinge = Constraint.create({
      bodyA: lever,
      pointA: { x: -LEVER_LENGTH/2, y: 0 },
      bodyB: pivot,
      pointB: { x: 0, y: 0 },
      length: 0,
      stiffness: 1
    });

    Composite.add(world, [lever, pivot, hinge]);

    // 「発射台」っぽさを出すためのガイド（見た目だけ）
    const guide = Bodies.rectangle(LAUNCH_X + 40, LAUNCH_Y + 5, 120, 10, {
      isStatic: true,
      angle: 0,
      render: { fillStyle: '#666' }
    });
    Composite.add(world, guide);

    // マウス制御
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: {
        stiffness: 0.2,
        render: { visible: false }
      }
    });
    Composite.add(world, mouseConstraint);

    render.mouse = mouse;

    // レバーの「自然な角度」（0 ラジアンより少し上向きにしておく）
    const REST_ANGLE = -0.2; // ラジアン（少し上向き）

    // レバーにかかる「バネトルク」の強さ
    const SPRING_STIFFNESS = 0.8; // 大きいほど強く戻る
    const SPRING_DAMPING   = 0.2; // 減衰（揺れを止めるため）

    // マウスでレバーをドラッグしているかどうか
    let isDraggingLever = false;

    // どのボディをつかんだか確認し、レバーならドラッグ中フラグを立てる
    Events.on(mouseConstraint, 'startdrag', (event) => {
      if (event.body === lever) {
        isDraggingLever = true;
        // ドラッグ中はレバーの角速度を0にしておく（手でゆっくり動かすイメージ）
        Body.setAngularVelocity(lever, 0);
      }
    });

    Events.on(mouseConstraint, 'enddrag', (event) => {
      if (event.body === lever) {
        // レバーから手を離した
        isDraggingLever = false;
        // ここからはバネの力で自動的に戻る
      }
    });

    // 毎フレーム、レバーに「バネトルク」を加える
    Events.on(engine, 'beforeUpdate', () => {
      // レバーの現在角度
      const angle = lever.angle;

      // 目標角度との差（REST_ANGLE が自然な位置）
      const angleError = angle - REST_ANGLE;

      // 角速度（回転スピード）
      const angVel = lever.angularVelocity;

      // バネトルク = -k * 角度差
      // 減衰トルク = -d * 角速度
      const torque = -SPRING_STIFFNESS * angleError - SPRING_DAMPING * angVel;

      // レバーをドラッグしている間も、バネのエネルギーは「ためて」おくイメージとして
      // 常にトルクは計算しておく（ただし、ドラッグ中はマウス制約が強く支配する）
      Body.applyForce(
        lever,
        lever.position,
        // トルクを擬似的に力に変換（レバーの長さで割る）
        {
          x: 0,
          y: torque / LEVER_LENGTH
        }
      );
    });

    // 10円が「レバー先端」に乗るように、定期的に位置を確認し、
    // レバーが戻るときに自然に弾かれるようにする
    // ここでは特別な制約は使わず、ただ置いておくだけ
    function resetCoinAndLever() {
      // 10円をリセット
      if (coin) {
        Composite.remove(world, coin);
      }
      coin = createCoin();
      Composite.add(world, coin);

      // レバーの角度と位置を初期化
      Body.setPosition(lever, { x: PIVOT_X + LEVER_LENGTH/2, y: PIVOT_Y });
      Body.setAngle(lever, REST_ANGLE);
      Body.setAngularVelocity(lever, 0);
      Body.setVelocity(lever, { x: 0, y: 0 });
    }

    document.getElementById('reset').addEventListener('click', resetCoinAndLever);

    // 初期状態
    resetCoinAndLever();
  </script>
</body>
</html>
