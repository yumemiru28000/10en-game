
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>10円 vs ren由来の坂（282x521縦長）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
    }
    #info {
      font-size: 12px;
      margin-bottom: 4px;
    }
    #canvasWrapper {
      position: relative;
      border: 1px solid #555;
      background: #000;
    }
    #controlPanel {
      font-size: 12px;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div id="info">
    ・キャンバスサイズは 282x521（10円ゲーム本番と同じ縦長）。<br>
    ・map.png / ren.png をこのサイズにフィットさせて描画。<br>
    ・ren の黒線をスキャンして「横方向の連続黒」を坂として抽出。<br>
    ・その坂に沿って 10円 が自然に転がるようにしつつ、貫通しにくいようにサブステップ＋押し出し強化。
  </div>

  <div id="canvasWrapper">
    <!-- ★ キャンバスサイズを 282 x 521 に固定 -->
    <canvas id="gameCanvas" width="282" height="521"></canvas>
  </div>

  <div id="controlPanel">
    重力: <input id="gravityInput" type="number" step="0.1" value="0.5">
    摩擦: <input id="frictionInput" type="number" step="0.01" value="0.02">
    静止閾値: <input id="staticInput" type="number" step="0.01" value="0.02">
    <button id="resetCoinBtn">10円リセット</button>
    <button id="playPauseBtn">一時停止</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gravityInput = document.getElementById("gravityInput");
    const frictionInput = document.getElementById("frictionInput");
    const staticInput = document.getElementById("staticInput");
    const resetCoinBtn = document.getElementById("resetCoinBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");

    // === ローカル or 同じオリジンに置いた画像を使うことを前提にしています ===
    // 例: 同じフォルダに map.png / ren.png を保存しておき、下のパスを "map.png", "ren.png" にする
    const MAP_URL = "map.png";
    const REN_URL = "ren.png";

    // 背景 map
    const bgImage = new Image();
    bgImage.src = MAP_URL;

    // ren.png （解析用）
    const renImage = new Image();
    renImage.src = REN_URL;
    const renCanvas = document.createElement("canvas");
    const renCtx    = renCanvas.getContext("2d");
    let renData = null;

    // 物理パラメータ
    let GRAVITY = parseFloat(gravityInput.value) || 0.5;
    let SLOPE_FRICTION = parseFloat(frictionInput.value) || 0.02;
    let STATIC_THRESHOLD = parseFloat(staticInput.value) || 0.02;

    gravityInput.addEventListener("input", () => {
      GRAVITY = parseFloat(gravityInput.value) || GRAVITY;
    });
    frictionInput.addEventListener("input", () => {
      SLOPE_FRICTION = parseFloat(frictionInput.value) || SLOPE_FRICTION;
    });
    staticInput.addEventListener("input", () => {
      STATIC_THRESHOLD = parseFloat(staticInput.value) || STATIC_THRESHOLD;
    });

    const coin = {
      x: canvas.width/2,
      y: 50,
      vx: 0,
      vy: 0,
      r: 12
    };

    // 複数坂
    const slopes = [];

    // 黒判定
    function isBlackAt(x, y) {
      if (!renData) return false;
      const ix = Math.floor(x), iy = Math.floor(y);
      if (ix < 0 || iy < 0 || ix >= renData.width || iy >= renData.height) return false;
      const idx = (iy * renData.width + ix) * 4;
      const r = renData.data[idx], g = renData.data[idx+1], b = renData.data[idx+2], a = renData.data[idx+3];
      return a > 20 && r < 40 && g < 40 && b < 40;
    }

    // 画像ロード完了を待つ
    let imagesLoaded = 0;
    bgImage.onload = onImageLoaded;
    renImage.onload = onImageLoaded;

    function onImageLoaded() {
      imagesLoaded++;
      if (imagesLoaded === 2) {
        initRenDataAndSlopes();
      }
    }

    function initRenDataAndSlopes() {
      // renCanvas も 282x521 に合わせる
      renCanvas.width  = canvas.width;
      renCanvas.height = canvas.height;
      // ren をキャンバスサイズにフィットさせて描画
      renCtx.drawImage(renImage, 0, 0, renCanvas.width, renCanvas.height);
      renData = renCtx.getImageData(0, 0, renCanvas.width, renCanvas.height);

      extractSlopesFromRen();
      resetCoinOnFirstSlope();
    }

    function extractSlopesFromRen() {
      slopes.length = 0;
      if (!renData) return;

      const w = renData.width;
      const h = renData.height;

      // 超簡易：「横方向の連続した黒」を1本の線分とみなす
      for (let y = 0; y < h; y += 2) {
        let x = 0;
        while (x < w) {
          // 黒区間の始まりを探す
          while (x < w && !isBlackAt(x, y)) x++;
          if (x >= w) break;
          const startX = x;
          // 黒が途切れるまで進む
          while (x < w && isBlackAt(x, y)) {
            x++;
          }
          const endX = x - 1;
          const length = endX - startX;
          if (length > 8) { // 短すぎる線は無視
            slopes.push({
              x1: startX,
              y1: y,
              x2: endX,
              y2: y
            });
          }
        }
      }

      console.log("抽出された坂の本数:", slopes.length);
    }

    function resetCoinOnFirstSlope() {
      if (slopes.length === 0) {
        coin.x = canvas.width/2;
        coin.y = 50;
      } else {
        const s = slopes[0];
        const mx = (s.x1 + s.x2)/2;
        const my = (s.y1 + s.y2)/2;
        const dx = s.x2 - s.x1;
        const dy = s.y2 - s.y1;
        const len = Math.sqrt(dx*dx + dy*dy) || 1;
        const nx = -(dy/len);
        const ny =  (dx/len);
        coin.x = mx + nx * coin.r;
        coin.y = my + ny * coin.r;
      }
      coin.vx = 0;
      coin.vy = 0;
    }

    resetCoinBtn.addEventListener("click", resetCoinOnFirstSlope);

    let paused = false;
    playPauseBtn.addEventListener("click", () => {
      paused = !paused;
      playPauseBtn.textContent = paused ? "再生" : "一時停止";
    });

    // 点 C と線分 AB の最近点
    function closestPointOnSegment(ax, ay, bx, by, cx, cy) {
      const abx = bx - ax;
      const aby = by - ay;
      const acx = cx - ax;
      const acy = cy - ay;
      const abLen2 = abx*abx + aby*aby || 1;
      let t = (acx * abx + acy * aby) / abLen2;
      t = Math.max(0, Math.min(1, t));
      const px = ax + abx * t;
      const py = ay + aby * t;
      const dx = cx - px;
      const dy = cy - py;
      const d = Math.sqrt(dx*dx + dy*dy);
      return { px, py, d, t };
    }

    // サブステップ + 押し出し強化版
    function updatePhysics() {
      if (paused) return;
      if (!renData) return;

      const SUB_STEPS = 3; // サブステップ数（多いほど貫通しにくい）
      const dt = 1 / SUB_STEPS;

      for (let step = 0; step < SUB_STEPS; step++) {
        // 1. 重力
        coin.vy += GRAVITY * dt;

        // 2. 自由移動
        coin.x += coin.vx * dt;
        coin.y += coin.vy * dt;

        // 3. 各坂と衝突＆坂上の運動（押し出しは最大3回まで）
        for (const s of slopes) {
          for (let iter = 0; iter < 3; iter++) { // 押し出し反復
            const { px, py, d } = closestPointOnSegment(
              s.x1, s.y1, s.x2, s.y2,
              coin.x, coin.y
            );
            if (d >= coin.r) break; // もう食い込んでいない

            const dx = s.x2 - s.x1;
            const dy = s.y2 - s.y1;
            const len = Math.sqrt(dx*dx + dy*dy) || 1;
            const tx = dx / len; // 接線
            const ty = dy / len;
            const nx = -ty;      // 法線
            const ny =  tx;

            // 円を外側へ押し出す（MTD）
            const penetration = coin.r - d + 0.2; // +0.2 で少し余裕を持たせる
            coin.x += nx * penetration;
            coin.y += ny * penetration;

            // 速度分解
            const vpx = coin.vx;
            const vpy = coin.vy;
            const v_parallel = vpx * tx + vpy * ty;
            let v_normal   = vpx * nx + vpy * ny;

            // 法線速度は 0 に近づける
            v_normal = 0;

            // 坂に沿った重力加速度
            const g_parallel = GRAVITY * ty * dt; // dt をかける
            let new_v_parallel = v_parallel + g_parallel;

            // 静止摩擦：加速度と速度が閾値以下なら止める
            if (Math.abs(g_parallel) < STATIC_THRESHOLD * dt &&
                Math.abs(v_parallel) < STATIC_THRESHOLD) {
              new_v_parallel = 0;
            } else {
              // 動摩擦：減衰
              new_v_parallel *= (1 - SLOPE_FRICTION);
            }

            // 合成
            coin.vx = new_v_parallel * tx + v_normal * nx;
            coin.vy = new_v_parallel * ty + v_normal * ny;
          }
        }

        // 4. 枠バウンド
        const bounce = 0.3;
        if (coin.x - coin.r < 0) {
          coin.x = coin.r;
          if (coin.vx < 0) coin.vx *= -bounce;
        }
        if (coin.x + coin.r > canvas.width) {
          coin.x = canvas.width - coin.r;
          if (coin.vx > 0) coin.vx *= -bounce;
        }
        if (coin.y - coin.r < 0) {
          coin.y = coin.r;
          if (coin.vy < 0) coin.vy *= -bounce;
        }
        if (coin.y + coin.r > canvas.height) {
          coin.y = canvas.height - coin.r;
          if (coin.vy > 0) coin.vy *= -bounce;
        }
      }
    }

    function draw() {
      if (!bgImage.complete) return;

      ctx.clearRect(0,0,canvas.width,canvas.height);
      // 背景：282x521 にフィットさせて描画
      ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);

      // ren由来の坂
      ctx.strokeStyle = "#44aaff";
      ctx.lineWidth = 2;
      for (const s of slopes) {
        ctx.beginPath();
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      }

      // 10円
      ctx.save();
      ctx.translate(coin.x, coin.y);
      ctx.fillStyle = "#cc8844";
      ctx.beginPath();
      ctx.arc(0,0,coin.r,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#5b3a10";
      ctx.font = "bold 10px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("10",0,0);
      ctx.restore();
    }

    function loop() {
      requestAnimationFrame(loop);
      if (!renData) return; // 画像読み込み待ち
      updatePhysics();
      draw();
    }

    loop();
  </script>
</body>
</html>
