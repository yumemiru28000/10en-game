<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>線の設計図エディタ（描画→数値出力→再生成）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }
    #leftPanel {
      width: 260px;
      background: #111;
      border-right: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
      overflow-y: auto;
    }
    #canvasWrapper {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #000;
    }
    #drawCanvas {
      background: #111;
      border: 1px solid #555;
      touch-action: none; /* タッチでスクロールさせない */
    }
    textarea {
      width: 100%;
      height: 140px;
      background: #000;
      color: #0f0;
      border: 1px solid #555;
      font-family: monospace;
      font-size: 11px;
      box-sizing: border-box;
      padding: 4px;
    }
    button {
      font-size: 11px;
      padding: 4px 8px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      margin: 2px 0;
    }
    button:hover {
      background: #444;
    }
    .label {
      font-size: 11px;
      color: #ccc;
    }
    input[type="number"] {
      width: 70px;
      background: #222;
      border: 1px solid #555;
      color: #eee;
      font-size: 11px;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="leftPanel">
    <div class="label"><strong>線の設計図エディタ</strong></div>
    <div class="label">
      1. 右のキャンバス上でドラッグして線を描く<br>
      2. 「数値として出力」を押すと、0〜1に正規化された座標配列が下に出ます<br>
      3. その配列をコードに貼り付けて保存できます<br>
      4. 配列を貼って「この配列から再生成」で、同じ形が再描画されます
    </div>

    <div>
      <span class="label">キャンバスサイズ</span><br>
      W: <input id="canvasWidthInput" type="number" value="564" min="50" max="2000">
      H: <input id="canvasHeightInput" type="number" value="1042" min="50" max="2000">
      <button id="resizeCanvasBtn">変更</button>
      <div class="label">※ map.png の実サイズなどに合わせるとよいです</div>
    </div>

    <div>
      <span class="label">描画モード</span><br>
      <button id="clearBtn">キャンバスをクリア</button>
      <div class="label">マウス/タッチでドラッグすると線が描けます。</div>
    </div>

    <div>
      <span class="label">数値出力（設計図）</span><br>
      <button id="exportBtn">数値として出力</button>
      <div class="label">形式: [[nx1,ny1],[nx2,ny2],...]（nx,ny は 0〜1 の比率）</div>
      <textarea id="outputArea" readonly></textarea>
    </div>

    <div>
      <span class="label">再生成（数値→線）</span><br>
      <div class="label">ここに数値配列を貼り付けて「この配列から再生成」を押します。</div>
      <textarea id="inputArea"></textarea>
      <button id="importBtn">この配列から再生成</button>
    </div>
  </div>

  <div id="canvasWrapper">
    <canvas id="drawCanvas" width="564" height="1042"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("drawCanvas");
    const ctx = canvas.getContext("2d");

    const canvasWidthInput  = document.getElementById("canvasWidthInput");
    const canvasHeightInput = document.getElementById("canvasHeightInput");
    const resizeCanvasBtn   = document.getElementById("resizeCanvasBtn");

    const clearBtn  = document.getElementById("clearBtn");
    const exportBtn = document.getElementById("exportBtn");
    const importBtn = document.getElementById("importBtn");

    const outputArea = document.getElementById("outputArea");
    const inputArea  = document.getElementById("inputArea");

    // 線は「パスの配列」として保持する: paths = [ [ {x,y}, {x,y}, ... ], ... ]
    let paths = [];
    let currentPath = null;
    let isDrawing = false;

    // サンプリング間隔（px）：描画中あまり細かくしすぎない
    const SAMPLE_DISTANCE = 4;

    function setCanvasSize(w, h) {
      canvas.width  = w;
      canvas.height = h;
      redrawAll();
    }

    resizeCanvasBtn.addEventListener("click", () => {
      const w = Math.max(50, Math.min(2000, parseInt(canvasWidthInput.value, 10)  || canvas.width));
      const h = Math.max(50, Math.min(2000, parseInt(canvasHeightInput.value, 10) || canvas.height));
      setCanvasSize(w, h);
    });

    clearBtn.addEventListener("click", () => {
      paths = [];
      currentPath = null;
      redrawAll();
      outputArea.value = "";
    });

    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      const x = (clientX - rect.left);
      const y = (clientY - rect.top);
      return { x, y };
    }

    let lastSamplePos = null;

    function startDrawing(e) {
      e.preventDefault();
      const pos = getCanvasPos(e);
      isDrawing = true;
      currentPath = [pos];
      lastSamplePos = pos;
      redrawAll();
    }

    function moveDrawing(e) {
      if (!isDrawing || !currentPath) return;
      e.preventDefault();
      const pos = getCanvasPos(e);
      const dx = pos.x - lastSamplePos.x;
      const dy = pos.y - lastSamplePos.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 >= SAMPLE_DISTANCE * SAMPLE_DISTANCE) {
        currentPath.push(pos);
        lastSamplePos = pos;
        redrawAll();
      }
    }

    function endDrawing(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      if (currentPath && currentPath.length > 1) {
        paths.push(currentPath);
      }
      currentPath = null;
      lastSamplePos = null;
      redrawAll();
    }

    // マウス
    canvas.addEventListener("mousedown", startDrawing);
    window.addEventListener("mousemove", moveDrawing);
    window.addEventListener("mouseup",   endDrawing);

    // タッチ
    canvas.addEventListener("touchstart", startDrawing, { passive: false });
    window.addEventListener("touchmove",  moveDrawing,  { passive: false });
    window.addEventListener("touchend",   endDrawing,   { passive: false });

    function redrawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 背景グリッド（薄く）
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
      const gridStep = 50;
      for (let x = 0; x <= canvas.width; x += gridStep) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += gridStep) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // 既存パス
      ctx.strokeStyle = "#0ff";
      ctx.lineWidth = 3;
      ctx.lineJoin = "round";
      ctx.lineCap  = "round";
      for (const path of paths) {
        if (path.length < 2) continue;
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
          ctx.lineTo(path[i].x, path[i].y);
        }
        ctx.stroke();
      }

      // 描画中のパス
      if (currentPath && currentPath.length >= 2) {
        ctx.strokeStyle = "#ff0";
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
          ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();
      }
    }

    // 描画済みの paths を [ [nx,ny], ... ] の配列(パスごとの配列)に変換
    function exportPaths() {
      const w = canvas.width;
      const h = canvas.height;
      // paths: [ [ {x,y},... ], [ ... ], ... ]
      const exported = paths.map(path => {
        return path.map(p => {
          const nx = +(p.x / w).toFixed(4); // 0〜1 の比率
          const ny = +(p.y / h).toFixed(4);
          return [nx, ny];
        });
      });
      return exported;
    }

    exportBtn.addEventListener("click", () => {
      const data = exportPaths();
      // コードにそのまま貼れる形（JSON）
      outputArea.value = JSON.stringify(data);
      // コピーしやすいよう選択しておくのもアリ
      outputArea.focus();
      outputArea.select();
    });

    // 入力された配列から paths を再構築
    function importPathsFromText(text) {
      let arr;
      try {
        arr = JSON.parse(text);
      } catch (e) {
        alert("JSON のパースに失敗しました。形式を確認してください。");
        return;
      }
      if (!Array.isArray(arr)) {
        alert("最上位が配列ではありません。[[[nx,ny],...], ...] の形式にしてください。");
        return;
      }

      const w = canvas.width;
      const h = canvas.height;
      const newPaths = [];
      for (const path of arr) {
        if (!Array.isArray(path)) continue;
        const pts = [];
        for (const p of path) {
          if (!Array.isArray(p) || p.length < 2) continue;
          const nx = Number(p[0]);
          const ny = Number(p[1]);
          if (Number.isNaN(nx) || Number.isNaN(ny)) continue;
          pts.push({
            x: nx * w,
            y: ny * h
          });
        }
        if (pts.length >= 2) {
          newPaths.push(pts);
        }
      }
      paths = newPaths;
      currentPath = null;
      redrawAll();
    }

    importBtn.addEventListener("click", () => {
      const text = inputArea.value.trim();
      if (!text) {
        alert("数値配列を貼り付けてください。");
        return;
      }
      importPathsFromText(text);
    });

    // 初回描画
    redrawAll();
  </script>
</body>
</html>
