<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円ゲーム マップ＆レバー実験（運営レバー設定付き）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }

    #uiPanel {
      width: 230px;
      background: #111;
      border-right: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }

    #leverArea {
      position: relative;
      width: 180px;
      height: 140px;
      margin: 0 auto;
      border: 1px solid #444;
      background: #181818;
      border-radius: 4px;
      touch-action: none;
    }

    #lever {
      position: absolute;
      width: 12px;
      height: 80px;
      background: #ccc;
      left: 50%;
      bottom: 15px;
      transform-origin: 50% 100%;
      transform: translateX(-50%) rotate(0deg);
      cursor: grab;
    }
    #lever:active {
      cursor: grabbing;
    }
    #lever::after {
      content: "";
      position: absolute;
      width: 30px;
      height: 12px;
      background: #ccc;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
    }
    #leverLabel {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      color: #aaa;
    }

    #leverInfo {
      font-size: 12px;
      line-height: 1.5;
    }

    #world {
      flex: 1;
      position: relative;
    }

    #world canvas {
      display: block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center center;
    }

    button {
      font-size: 11px;
      padding: 3px 6px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      margin: 1px 0;
    }
    button:hover {
      background: #444;
    }
    input[type="number"],
    input[type="password"],
    input[type="text"] {
      width: 80px;
      background: #222;
      border: 1px solid #555;
      color: #eee;
      padding: 2px 4px;
      border-radius: 3px;
      margin: 1px 0;
      font-size: 11px;
    }

    #adminPanel {
      border-top: 1px solid #333;
      padding-top: 6px;
      margin-top: 6px;
      font-size: 11px;
    }

    #adminStatus {
      font-size: 11px;
      color: #ccc;
      margin-bottom: 4px;
    }

    #adminControls {
      margin-top: 4px;
      display: none; /* 運営だけ表示 */
    }

    #stickControls {
      border-top: 1px solid #333;
      margin-top: 4px;
      padding-top: 4px;
    }

    #stickThickness {
      width: 100%;
    }

    #stickInfo {
      font-size: 11px;
      color: #aaa;
    }

    #leverConfig {
      border-top: 1px solid #333;
      margin-top: 4px;
      padding-top: 4px;
      font-size: 11px;
    }

    .smallLabel {
      font-size: 10px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <div id="uiPanel">
    <!-- レバー UI（実際に操作すると「選択中レバー」の設定を使って発射） -->
    <div id="leverArea">
      <div id="lever"></div>
      <div id="leverLabel">レバー</div>
    </div>
    <div id="leverInfo">
      角度: <span id="angleText">0</span>°<br>
      引き具合(0～1): <span id="powerText">0.00</span>
    </div>

    <!-- 一般ユーザーにも見える基本操作 -->
    <div>
      重力:
      <input id="gravity" type="number" step="0.1" value="1.0"><br>
      <button id="addCoin">10円を置く</button>
      <button id="resetWorld">10円リセット</button>
    </div>

    <!-- 運営モード（最初はパス入力だけ見える） -->
    <div id="adminPanel">
      <div><strong>運営モード</strong></div>
      <div id="adminStatus">未ログイン</div>
      パスワード:
      <input id="adminPass" type="password" placeholder="1122">
      <button id="adminLogin">ログイン</button>

      <!-- ここから下は運営だけに表示 -->
      <div id="adminControls">
        <!-- レバー/スポーン設定 -->
        <div id="leverConfig">
          <div><strong>レバー設定 (1～N)</strong></div>
          <div>
            レバー番号:
            <input id="leverIndex" type="number" min="1" step="1" value="1" style="width:40px;">
            <button id="loadLeverConfig">読込</button>
          </div>
          <div class="smallLabel">※新しい番号を指定すると自動で新規作成</div>

          <div>
            <span class="smallLabel">レバー位置 (x,y)</span><br>
            x: <input id="leverPosX" type="number" value="260">
            y: <input id="leverPosY" type="number" value="320">
          </div>
          <div>
            <span class="smallLabel">打ち出し方向(度) / 強さ</span><br>
            角度: <input id="leverDirDeg" type="number" value="-45"><br>
            Max速度: <input id="leverMaxSpeed" type="number" value="35">
          </div>
          <div>
            <span class="smallLabel">10円スポーン位置 (x,y)</span><br>
            sx: <input id="spawnPosX" type="number" value="260">
            sy: <input id="spawnPosY" type="number" value="320">
          </div>
          <button id="saveLeverConfig">この番号に保存</button><br>
          <button id="resetLeverConfigs">レバー設定 全リセット</button><br>
          <button id="resetSpawns">スポーン 全リセット</button>
        </div>

        <!-- 棒（線分）編集 -->
        <div id="stickControls">
          <div><strong>棒編集</strong></div>
          <button id="toggleStickEdit">棒編集モード: OFF</button><br>
          太さ:
          <input id="stickThickness" type="range" min="5" max="50" value="20">
          <span id="stickThicknessLabel">20</span> px<br>
          <button id="resetSticks">棒 全リセット</button>
          <div id="stickInfo">
            棒編集モード中: キャンバス上を2回クリックで棒を作成。
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="world"></div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ============================================================
    // 基本設定
    // ============================================================
    const REBA_HEAVINESS_EXPONENT = 3.0;   // 引くほど重く
    const REBA_MAX_ANGLE_DEG      = 90;
    const REBA_DRAG_SENSITIVITY   = 0.5;
    const REBA_LAUNCH_RADIUS      = 30;

    // 10円（5.5g） + 斜面でよく転がるように摩擦をかなり弱く
    const COIN_RADIUS = 11;
    const COIN_MASS   = 0.0055;
    const COIN_FRICTION        = 0.01;
    const COIN_FRICTION_STATIC = 0.02;
    const COIN_FRICTION_AIR    = 0.0003;

    // テスト用の「ごくわずかな斜面」
    const REBA_TEST_SLOPE_ANGLE = 0.03;

    // マップ画像
    const MAP_IMAGE_URL = "https://raw.githubusercontent.com/yumemiru28000/10en-game/main/map.png";

    // ============================================================
    // Matter.js セットアップ
    // ============================================================
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const Runner = Matter.Runner;
    const Bodies = Matter.Bodies;
    const Composite = Matter.Composite;
    const Body = Matter.Body;
    const Mouse = Matter.Mouse;
    const MouseConstraint = Matter.MouseConstraint;

    const engine = Engine.create();
    const world  = engine.world;
    engine.world.gravity.y = 1.0;

    const canvasWidth  = window.innerWidth - 230;
    const canvasHeight = window.innerHeight;

    const render = Render.create({
      element: document.getElementById("world"),
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: "#000"
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // マップ画像を背景に
    render.canvas.style.backgroundImage = `url("${MAP_IMAGE_URL}")`;
    render.canvas.style.backgroundSize = "contain";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "center center";

    // ============================================================
    // 壁・斜面
    // ============================================================
    const thickness = 40;

    const leftWall = Bodies.rectangle(20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const rightWall = Bodies.rectangle(canvasWidth - 20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const ceiling = Bodies.rectangle(canvasWidth / 2, 20, canvasWidth, thickness, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });

    const floorAngle = -Math.PI / 8;
    const floorLength = 500;
    const slopedFloor = Bodies.rectangle(
      canvasWidth - 260,
      canvasHeight - 60,
      floorLength,
      20,
      {
        isStatic: true,
        angle: floorAngle,
        render: { fillStyle: "rgba(120,120,120,0.7)" }
      }
    );

    const cornerPost = Bodies.rectangle(
      canvasWidth - 350,
      canvasHeight - 150,
      20,
      80,
      {
        isStatic: true,
        render: { fillStyle: "rgba(160,160,160,0.7)" }
      }
    );

    const gentleSlope = Bodies.rectangle(
      canvasWidth / 2,
      canvasHeight / 2 + 80,
      350,
      10,
      {
        isStatic: true,
        angle: REBA_TEST_SLOPE_ANGLE,
        render: { fillStyle: "rgba(100,100,100,0.7)" }
      }
    );

    Composite.add(world, [leftWall, rightWall, ceiling, slopedFloor, cornerPost, gentleSlope]);

    // ============================================================
    // 棒編集（運営専用）
    // ============================================================
    const stickBodies = [];
    let isAdmin = false;
    let stickEditMode = false;
    let pendingPoint = null;
    const adminStatusEl = document.getElementById("adminStatus");
    const adminPassEl   = document.getElementById("adminPass");
    const adminLoginBtn = document.getElementById("adminLogin");
    const adminControlsEl = document.getElementById("adminControls");
    const toggleStickEditBtn = document.getElementById("toggleStickEdit");
    const resetSticksBtn     = document.getElementById("resetSticks");
    const stickThicknessInput= document.getElementById("stickThickness");
    const stickThicknessLabel= document.getElementById("stickThicknessLabel");

    let currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;

    stickThicknessInput.addEventListener("input", () => {
      currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;
      stickThicknessLabel.textContent = currentStickThickness;
    });
    stickThicknessLabel.textContent = currentStickThickness;

    adminLoginBtn.addEventListener("click", () => {
      if (adminPassEl.value === "1122") {
        isAdmin = true;
        adminStatusEl.textContent = "ログイン中（運営モード）";
        adminControlsEl.style.display = "block";
      } else {
        adminStatusEl.textContent = "パスワード不正";
      }
    });

    toggleStickEditBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      stickEditMode = !stickEditMode;
      toggleStickEditBtn.textContent = "棒編集モード: " + (stickEditMode ? "ON" : "OFF");
      if (!stickEditMode) pendingPoint = null;
    });

    resetSticksBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      for (const b of stickBodies) {
        Composite.remove(world, b);
      }
      stickBodies.length = 0;
      pendingPoint = null;
    });

    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: {
        stiffness: 0.1,
        render: { visible: false }
      }
    });
    Composite.add(world, mouseConstraint);
    render.mouse = mouse;

    render.canvas.addEventListener("mousedown", (e) => {
      if (!isAdmin || !stickEditMode) return;
      const rect = render.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (!pendingPoint) {
        pendingPoint = { x, y };
      } else {
        const x1 = pendingPoint.x;
        const y1 = pendingPoint.y;
        const x2 = x;
        const y2 = y;
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        const stick = Bodies.rectangle(
          cx,
          cy,
          length,
          currentStickThickness,
          {
            isStatic: true,
            angle: angle,
            render: { fillStyle: "rgba(180,180,180,0.8)" }
          }
        );
        Composite.add(world, stick);
        stickBodies.push(stick);
        pendingPoint = null;
      }
    });

    // ============================================================
    // レバー設定 (1～N 番) ＋ スポーン位置
    // ============================================================
    // 簡易的に JS 内の配列で保持（本番ではサーバ保存などに拡張可能）
    const leverConfigs = {}; // key: index, value: { leverX, leverY, dirDeg, maxSpeed, spawnX, spawnY }

    // デフォルト（1番）を入れておく
    leverConfigs[1] = {
      leverX: 260,
      leverY: 320,
      dirDeg: -45,
      maxSpeed: 35,
      spawnX: 260,
      spawnY: 320
    };

    // 現在選択中のレバー番号
    let currentLeverIndex = 1;

    const leverIndexInput  = document.getElementById("leverIndex");
    const leverPosXInput   = document.getElementById("leverPosX");
    const leverPosYInput   = document.getElementById("leverPosY");
    const leverDirDegInput = document.getElementById("leverDirDeg");
    const leverMaxSpeedInput = document.getElementById("leverMaxSpeed");
    const spawnPosXInput   = document.getElementById("spawnPosX");
    const spawnPosYInput   = document.getElementById("spawnPosY");

    const loadLeverConfigBtn   = document.getElementById("loadLeverConfig");
    const saveLeverConfigBtn   = document.getElementById("saveLeverConfig");
    const resetLeverConfigsBtn = document.getElementById("resetLeverConfigs");
    const resetSpawnsBtn       = document.getElementById("resetSpawns");

    function loadLeverConfig(index) {
      if (!leverConfigs[index]) {
        // 存在しなければ、1番の設定をコピーして新規作成
        const base = leverConfigs[1] || {
          leverX: 260, leverY: 320,
          dirDeg: -45, maxSpeed: 35,
          spawnX: 260, spawnY: 320
        };
        leverConfigs[index] = { ...base };
      }
      const cfg = leverConfigs[index];
      leverPosXInput.value   = cfg.leverX;
      leverPosYInput.value   = cfg.leverY;
      leverDirDegInput.value = cfg.dirDeg;
      leverMaxSpeedInput.value = cfg.maxSpeed;
      spawnPosXInput.value   = cfg.spawnX;
      spawnPosYInput.value   = cfg.spawnY;
      currentLeverIndex = index;
    }

    function saveLeverConfig(index) {
      leverConfigs[index] = {
        leverX: parseFloat(leverPosXInput.value)   || 0,
        leverY: parseFloat(leverPosYInput.value)   || 0,
        dirDeg: parseFloat(leverDirDegInput.value) || 0,
        maxSpeed: parseFloat(leverMaxSpeedInput.value) || 20,
        spawnX: parseFloat(spawnPosXInput.value)   || 0,
        spawnY: parseFloat(spawnPosYInput.value)   || 0
      };
      currentLeverIndex = index;
    }

    loadLeverConfigBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      const idx = parseInt(leverIndexInput.value, 10) || 1;
      loadLeverConfig(idx);
    });

    saveLeverConfigBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      const idx = parseInt(leverIndexInput.value, 10) || 1;
      saveLeverConfig(idx);
    });

    resetLeverConfigsBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      for (const k in leverConfigs) delete leverConfigs[k];
      leverConfigs[1] = {
        leverX: 260,
        leverY: 320,
        dirDeg: -45,
        maxSpeed: 35,
        spawnX: 260,
        spawnY: 320
      };
      leverIndexInput.value = 1;
      loadLeverConfig(1);
    });

    resetSpawnsBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      for (const k in leverConfigs) {
        const c = leverConfigs[k];
        c.spawnX = c.leverX;
        c.spawnY = c.leverY;
      }
      const idx = parseInt(leverIndexInput.value, 10) || 1;
      loadLeverConfig(idx);
    });

    // 起動時に 1番設定をUIへロード
    leverIndexInput.value = 1;
    loadLeverConfig(1);

    // ============================================================
    // コイン（10円）
    // ============================================================
    const coins = [];

    function createCoin(x, y) {
      return Bodies.circle(x, y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: 0.2,
        friction: COIN_FRICTION,
        frictionStatic: COIN_FRICTION_STATIC,
        frictionAir: COIN_FRICTION_AIR,
        render: {
          fillStyle: "#cc8844",
          strokeStyle: "#ddbb77",
          lineWidth: 2
        }
      });
    }

    function addCoinAt(x, y) {
      const c = createCoin(x, y);
      coins.push(c);
      Composite.add(world, c);
      return c;
    }

    // 初期：現在レバー設定のspawn位置に1枚
    function spawnInitialCoinForCurrentLever() {
      const cfg = leverConfigs[currentLeverIndex];
      if (!cfg) return;
      addCoinAt(cfg.spawnX, cfg.spawnY);
    }
    spawnInitialCoinForCurrentLever();

    // 発射スリット（見た目）
    function createLaunchSlotForLever(cfg) {
      const blockThickness = 20;
      const baseBlockWidth = 80;
      const x = cfg.leverX;
      const y = cfg.leverY;

      const slotUpper = Bodies.rectangle(
        x,
        y - COIN_RADIUS - 5,
        baseBlockWidth,
        blockThickness,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      const slotLower = Bodies.rectangle(
        x,
        y + COIN_RADIUS + 5,
        baseBlockWidth,
        blockThickness,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      const slotLeftWall = Bodies.rectangle(
        x - baseBlockWidth / 2 + 10,
        y,
        20,
        COIN_RADIUS * 4,
        { isStatic: true, render: { fillStyle: "rgba(60,60,60,0.8)" } }
      );
      return [slotUpper, slotLower, slotLeftWall];
    }

    // いったん1番のスリットだけ作成（必要なら複数レバーに拡張可）
    const initialSlotBodies = createLaunchSlotForLever(leverConfigs[1]);
    Composite.add(world, initialSlotBodies);

    // ============================================================
    // レバー UI → 現在選択レバーの設定を使って発射
    // ============================================================
    const leverEl = document.getElementById("lever");
    const angleTextEl = document.getElementById("angleText");
    const powerTextEl = document.getElementById("powerText");
    const gravityInput = document.getElementById("gravity");
    const addCoinBtn = document.getElementById("addCoin");
    const resetWorldBtn = document.getElementById("resetWorld");

    let leverAngleDeg = 0;
    let isDraggingLever = false;
    let dragStartY = 0;
    let dragStartAngle = 0;

    function calcPullPower() {
      const normalized = leverAngleDeg / REBA_MAX_ANGLE_DEG;
      return Math.pow(normalized, REBA_HEAVINESS_EXPONENT);
    }

    function updateLeverVisual() {
      leverEl.style.transform = `translateX(-50%) rotate(${leverAngleDeg}deg)`;
      angleTextEl.textContent = leverAngleDeg.toFixed(1);
      powerTextEl.textContent = calcPullPower().toFixed(2);
    }

    function getCurrentLeverConfig() {
      return leverConfigs[currentLeverIndex] || leverConfigs[1];
    }

    function getLaunchDirection() {
      const cfg = getCurrentLeverConfig();
      const rad = (cfg.dirDeg || 0) * Math.PI / 180;
      return { x: Math.cos(rad), y: Math.sin(rad) };
    }

    function getLaunchPower() {
      const cfg = getCurrentLeverConfig();
      const baseMaxSpeed = cfg.maxSpeed || 25;
      return calcPullPower() * baseMaxSpeed;
    }

    function releaseLeverAndLaunch() {
      const power = getLaunchPower();
      if (power <= 0.1) {
        leverAngleDeg = 0;
        updateLeverVisual();
        return;
      }
      const cfg = getCurrentLeverConfig();
      const dir = getLaunchDirection();

      coins.forEach(c => {
        const dx = c.position.x - cfg.leverX;
        const dy = c.position.y - cfg.leverY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < REBA_LAUNCH_RADIUS) {
          const vx = dir.x * power;
          const vy = dir.y * power;
          Body.setVelocity(c, { x: vx, y: vy });
        }
      });

      leverAngleDeg = 0;
      updateLeverVisual();
    }

    function startDragLever(startY) {
      isDraggingLever = true;
      dragStartY = startY;
      dragStartAngle = leverAngleDeg;
    }
    function moveDragLever(currentY) {
      if (!isDraggingLever) return;
      const dy = currentY - dragStartY;
      let newAngle = dragStartAngle + dy * REBA_DRAG_SENSITIVITY;
      newAngle = Math.max(0, Math.min(REBA_MAX_ANGLE_DEG, newAngle));
      leverAngleDeg = newAngle;
      updateLeverVisual();
    }
    function endDragLever() {
      if (!isDraggingLever) return;
      isDraggingLever = false;
      releaseLeverAndLaunch();
    }

    // マウス
    leverEl.addEventListener("mousedown", e => {
      e.preventDefault();
      startDragLever(e.clientY);
    });
    window.addEventListener("mousemove", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      moveDragLever(e.clientY);
    });
    window.addEventListener("mouseup", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    });

    // タッチ
    leverEl.addEventListener("touchstart", e => {
      e.preventDefault();
      const t = e.touches[0];
      startDragLever(t.clientY);
    }, { passive: false });
    window.addEventListener("touchmove", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      const t = e.touches[0];
      moveDragLever(t.clientY);
    }, { passive: false });
    window.addEventListener("touchend", e => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    }, { passive: false });

    updateLeverVisual();

    // ============================================================
    // UI ボタン
    // ============================================================
    gravityInput.addEventListener("input", e => {
      const g = parseFloat(e.target.value) || 0;
      engine.world.gravity.y = g;
    });

    addCoinBtn.addEventListener("click", () => {
      const cfg = getCurrentLeverConfig();
      const x = cfg.spawnX + (Math.random() * 10 - 5);
      const y = cfg.spawnY + (Math.random() * 10 - 5);
      addCoinAt(x, y);
    });

    resetWorldBtn.addEventListener("click", () => {
      coins.forEach(c => Composite.remove(world, c));
      coins.length = 0;
      spawnInitialCoinForCurrentLever();
      leverAngleDeg = 0;
      updateLeverVisual();
    });

    // ============================================================
    // 「斜面に接しているときそっちに転がる」について
    // ============================================================
    // Matter.js では、重力ベクトルと面の角度、摩擦で自然に「そっち方向に転がる」。
    // それが弱いと感じる場合は「摩擦が強すぎる・空気抵抗が大きすぎる」になるので、
    // 上で COIN_FRICTION / COIN_FRICTION_STATIC / COIN_FRICTION_AIR をかなり小さくしている。
    // 必要ならさらに 0.005 / 0.01 / 0.0001 くらいまで落として試してみてください。
  </script>
</body>
</html>
