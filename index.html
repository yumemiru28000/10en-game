
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円ゲーム 統合実験版（マップ＋複数レバー＋棒編集）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }

    #uiPanel {
      width: 260px;
      background: #111;
      border-right: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }

    #world {
      flex: 1;
      position: relative;
    }

    #world canvas {
      display: block;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center center;
    }

    /* レバー UI 共通 */
    .leverArea {
      position: relative;
      width: 220px;
      height: 120px;
      margin: 4px auto;
      border: 1px solid #444;
      background: #181818;
      border-radius: 4px;
      touch-action: none;
    }

    .lever {
      position: absolute;
      width: 12px;
      height: 70px;
      background: #ccc;
      left: 50%;
      bottom: 15px;
      transform-origin: 50% 100%;
      transform: translateX(-50%) rotate(0deg);
      cursor: grab;
    }
    .lever:active {
      cursor: grabbing;
    }
    .lever::after {
      content: "";
      position: absolute;
      width: 30px;
      height: 12px;
      background: #ccc;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
    }
    .leverLabel {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      color: #aaa;
    }

    button {
      font-size: 11px;
      padding: 3px 6px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
      margin: 1px 0;
    }
    button:hover {
      background: #444;
    }

    input[type="number"], input[type="password"] {
      background: #222;
      border: 1px solid #555;
      color: #eee;
      padding: 2px 4px;
      border-radius: 3px;
    }

    input[type="number"] {
      width: 60px;
    }

    #adminPanel {
      border-top: 1px solid #333;
      padding-top: 4px;
      margin-top: 4px;
      font-size: 11px;
    }
    #adminPanel.disabled {
      opacity: 0.4;
    }

    #adminStatus {
      font-size: 11px;
      color: #ccc;
      margin-bottom: 4px;
    }

    #stickInfo {
      font-size: 11px;
      color: #aaa;
    }

    #stickThickness {
      width: 100%;
    }

    .leverConfig {
      border: 1px solid #333;
      border-radius: 4px;
      padding: 4px;
      margin-bottom: 4px;
      font-size: 11px;
    }
    .leverConfigTitle {
      font-weight: bold;
      margin-bottom: 2px;
    }
  </style>
</head>
<body>
  <div id="uiPanel">
    <!-- 共通設定（運営/一般 共通で見える） -->
    <div>
      <div><strong>全体設定</strong></div>
      重力:
      <input id="gravity" type="number" step="0.1" value="1.0">
      <button id="addCoinGlobal">10円を追加</button>
    </div>

    <!-- 運営モード ログインのみ常に表示 -->
    <div id="adminLoginPanel">
      <div><strong>運営モード ログイン</strong></div>
      <div id="adminStatus">未ログイン</div>
      パスワード:
      <input id="adminPass" type="password" placeholder="1122">
      <button id="adminLogin">ログイン</button>
    </div>

    <!-- 運営専用パネル（ログイン後にまとめて表示） -->
    <div id="adminPanel" class="disabled" style="display:none;">
      <div><strong>運営メニュー</strong></div>

      <!-- レバー 1〜N 設定 -->
      <div id="leverContainer"></div>

      <!-- 棒編集 -->
      <div style="border-top:1px solid #333; margin-top:4px; padding-top:4px;">
        <div><strong>棒編集</strong></div>
        <button id="toggleStickEdit">棒編集モード: OFF</button><br>
        棒の太さ:
        <input id="stickThickness" type="range" min="5" max="50" value="20">
        <span id="stickThicknessLabel">20</span> px<br>
        <button id="resetSticks">棒 全リセット</button>
        <div id="stickInfo">
          棒編集モード中: キャンバス上を2回クリックすると、その2点をつなぐ棒が作られます。
        </div>
      </div>

      <!-- 10円 全リセット -->
      <div style="border-top:1px solid #333; margin-top:4px; padding-top:4px;">
        <button id="resetAllCoins">10円 全リセット</button>
      </div>
    </div>
  </div>

  <div id="world"></div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ============================================================
    // 設定用定数
    // ============================================================
    // レバーの共通特性（「重くなる度合い」など）
    const REBA_HEAVINESS_EXPONENT = 3.0;
    const REBA_MAX_ANGLE_DEG      = 90;
    const REBA_DRAG_SENSITIVITY   = 0.5;

    // 10円（5.5g）＋よく転がる用の摩擦
    const COIN_RADIUS = 11;
    const COIN_MASS   = 0.0055;
    const COIN_FRICTION       = 0.02;
    const COIN_FRICTION_STATIC= 0.05;
    const COIN_FRICTION_AIR   = 0.0005;
    const COIN_RESTITUTION    = 0.2;

    // 斜面での「下向き成分に応じた追加加速」の強さ
    // 大きいほど、斜面に沿ってどんどん加速する
    const SLOPE_BOOST_FACTOR = 0.0008;

    // 中央のテスト用わずかな斜面の角度（ラジアン）
    const REBA_TEST_SLOPE_ANGLE = 0.04;

    // マップ画像
    const MAP_IMAGE_URL = "https://raw.githubusercontent.com/yumemiru28000/10en-game/main/map.png";

    // レバーの数（1〜N）
    const LEVER_COUNT = 2;

    // 各レバーの初期設定
    const initialLevers = [
      {
        id: 1,
        label: "レバー1",
        spawnX: 260,
        spawnY: 320,
        launchX: 260,
        launchY: 320,
        launchAngleDeg: -45,
        maxLaunchSpeed: 35,
        launchRadius: 30
      },
      {
        id: 2,
        label: "レバー2",
        spawnX: 600,
        spawnY: 300,
        launchX: 600,
        launchY: 300,
        launchAngleDeg: -60,
        maxLaunchSpeed: 30,
        launchRadius: 35
      }
    ];

    // ============================================================
    // Matter.js セットアップ
    // ============================================================
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const Runner = Matter.Runner;
    const Bodies = Matter.Bodies;
    const Composite = Matter.Composite;
    const Body = Matter.Body;
    const Mouse = Matter.Mouse;
    const MouseConstraint = Matter.MouseConstraint;

    const engine = Engine.create();
    const world  = engine.world;
    engine.world.gravity.y = 1.0;

    const canvasWidth  = window.innerWidth - 260;
    const canvasHeight = window.innerHeight;

    const render = Render.create({
      element: document.getElementById("world"),
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: "#000"
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // map.png を背景に
    render.canvas.style.backgroundImage = `url("${MAP_IMAGE_URL}")`;
    render.canvas.style.backgroundSize = "contain";
    render.canvas.style.backgroundRepeat = "no-repeat";
    render.canvas.style.backgroundPosition = "center center";

    // ============================================================
    // フィールド（壁・斜面）
    // ============================================================
    const thickness = 40;

    const leftWall = Bodies.rectangle(20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const rightWall = Bodies.rectangle(canvasWidth - 20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });
    const ceiling = Bodies.rectangle(canvasWidth / 2, 20, canvasWidth, thickness, {
      isStatic: true,
      render: { fillStyle: "rgba(80,80,80,0.6)" }
    });

    // 右下 大きめ斜面
    const floorAngle = -Math.PI / 8;
    const floorLength = 500;
    const slopedFloor = Bodies.rectangle(
      canvasWidth - 260,
      canvasHeight - 60,
      floorLength,
      20,
      {
        isStatic: true,
        angle: floorAngle,
        render: { fillStyle: "rgba(120,120,120,0.7)" }
      }
    );

    const cornerPost = Bodies.rectangle(
      canvasWidth - 350,
      canvasHeight - 150,
      20,
      80,
      {
        isStatic: true,
        render: { fillStyle: "rgba(160,160,160,0.7)" }
      }
    );

    // わずかな斜面
    const gentleSlope = Bodies.rectangle(
      canvasWidth / 2,
      canvasHeight / 2 + 80,
      350,
      10,
      {
        isStatic: true,
        angle: REBA_TEST_SLOPE_ANGLE,
        render: { fillStyle: "rgba(100,100,100,0.7)" }
      }
    );

    Composite.add(world, [leftWall, rightWall, ceiling, slopedFloor, cornerPost, gentleSlope]);

    // ============================================================
    // 棒編集（運営専用）
    // ============================================================
    const stickBodies = [];
    let isAdmin = false;
    let stickEditMode = false;
    let pendingPoint = null;
    const adminPanelEl = document.getElementById("adminPanel");
    const adminStatusEl = document.getElementById("adminStatus");
    const adminPassEl   = document.getElementById("adminPass");
    const adminLoginBtn = document.getElementById("adminLogin");
    const toggleStickEditBtn = document.getElementById("toggleStickEdit");
    const resetSticksBtn     = document.getElementById("resetSticks");
    const stickThicknessInput= document.getElementById("stickThickness");
    const stickThicknessLabel= document.getElementById("stickThicknessLabel");

    let currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;
    stickThicknessLabel.textContent = currentStickThickness;

    stickThicknessInput.addEventListener("input", () => {
      currentStickThickness = parseInt(stickThicknessInput.value, 10) || 20;
      stickThicknessLabel.textContent = currentStickThickness;
    });

    adminLoginBtn.addEventListener("click", () => {
      if (adminPassEl.value === "1122") {
        isAdmin = true;
        adminStatusEl.textContent = "ログイン中（運営モード）";
        adminPanelEl.classList.remove("disabled");
        adminPanelEl.style.display = "block"; // 運営 UI 全表示
      } else {
        adminStatusEl.textContent = "パスワード不正";
      }
    });

    toggleStickEditBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      stickEditMode = !stickEditMode;
      toggleStickEditBtn.textContent = "棒編集モード: " + (stickEditMode ? "ON" : "OFF");
      if (!stickEditMode) pendingPoint = null;
    });

    resetSticksBtn.addEventListener("click", () => {
      if (!isAdmin) return;
      for (const b of stickBodies) {
        Composite.remove(world, b);
      }
      stickBodies.length = 0;
      pendingPoint = null;
    });

    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: {
        stiffness: 0.1,
        render: { visible: false }
      }
    });
    Composite.add(world, mouseConstraint);
    render.mouse = mouse;

    render.canvas.addEventListener("mousedown", (e) => {
      if (!isAdmin || !stickEditMode) return;
      const rect = render.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (!pendingPoint) {
        pendingPoint = { x, y };
      } else {
        const x1 = pendingPoint.x;
        const y1 = pendingPoint.y;
        const x2 = x;
        const y2 = y;
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        const stick = Bodies.rectangle(
          cx,
          cy,
          length,
          currentStickThickness,
          {
            isStatic: true,
            angle: angle,
            render: { fillStyle: "rgba(180,180,180,0.8)" }
          }
        );
        Composite.add(world, stick);
        stickBodies.push(stick);
        pendingPoint = null;
      }
    });

    // ============================================================
    // 10円玉
    // ============================================================
    const coins = [];

    function createCoin(x, y) {
      return Bodies.circle(x, y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: COIN_RESTITUTION,
        friction: COIN_FRICTION,
        frictionStatic: COIN_FRICTION_STATIC,
        frictionAir: COIN_FRICTION_AIR,
        render: {
          fillStyle: "#cc8844",
          strokeStyle: "#ddbb77",
          lineWidth: 2
        }
      });
    }

    function addCoinAt(x, y) {
      const c = createCoin(x, y);
      coins.push(c);
      Composite.add(world, c);
      return c;
    }

    // ============================================================
    // レバー / スポーン / 飛ばす範囲 可視化
    // ============================================================
    const leverContainerEl = document.getElementById("leverContainer");
    const globalAddCoinBtn = document.getElementById("addCoinGlobal");
    const resetAllCoinsBtn = document.getElementById("resetAllCoins");
    const gravityInput = document.getElementById("gravity");

    gravityInput.addEventListener("input", e => {
      const g = parseFloat(e.target.value) || 0;
      engine.world.gravity.y = g;
    });

    globalAddCoinBtn.addEventListener("click", () => {
      // 適当に中央付近に追加
      addCoinAt(canvasWidth / 2, canvasHeight / 2);
    });

    if (resetAllCoinsBtn) {
      resetAllCoinsBtn.addEventListener("click", () => {
        coins.forEach(c => Composite.remove(world, c));
        coins.length = 0;
      });
    }

    // レバーごとの状態
    const leverStates = [];

    function createLeverUIAndLogic(config) {
      // UIブロック
      const wrapper = document.createElement("div");
      wrapper.className = "leverConfig";

      const title = document.createElement("div");
      title.className = "leverConfigTitle";
      title.textContent = config.label + "（ID " + config.id + "）";
      wrapper.appendChild(title);

      // レバー UI エリア
      const leverArea = document.createElement("div");
      leverArea.className = "leverArea";
      const leverEl = document.createElement("div");
      leverEl.className = "lever";
      const leverLabel = document.createElement("div");
      leverLabel.className = "leverLabel";
      leverLabel.textContent = "レバー";
      leverArea.appendChild(leverEl);
      leverArea.appendChild(leverLabel);
      wrapper.appendChild(leverArea);

      // 情報表示
      const info = document.createElement("div");
      info.innerHTML = `
        角度: <span class="angleText">0</span>° /
        引き: <span class="powerText">0.00</span>
      `;
      wrapper.appendChild(info);

      // スポーン位置・発射位置・向き・強さ
      const coordBlock = document.createElement("div");
      coordBlock.innerHTML = `
        <div>スポーン位置 X:<input class="spawnX" type="number" value="${config.spawnX}">
             Y:<input class="spawnY" type="number" value="${config.spawnY}"></div>
        <div>レバー発射位置 X:<input class="launchX" type="number" value="${config.launchX}">
             Y:<input class="launchY" type="number" value="${config.launchY}"></div>
        <div>打ち出し角度(度):<input class="angleLaunch" type="number" value="${config.launchAngleDeg}">
        </div>
        <div>最大強さ:<input class="maxSpeed" type="number" value="${config.maxLaunchSpeed}">
        </div>
        <div>範囲半径:<input class="radius" type="number" value="${config.launchRadius}">
        </div>
        <div>
          <button class="spawnCoin">スポーン位置に10円追加</button>
          <button class="resetSpawnCoin">スポーン位置リセット</button>
          <button class="resetLever">レバー角度リセット</button>
        </div>
      `;
      wrapper.appendChild(coordBlock);

      leverContainerEl.appendChild(wrapper);

      // 要素取得
      const angleTextEl = info.querySelector(".angleText");
      const powerTextEl = info.querySelector(".powerText");
      const spawnXEl    = coordBlock.querySelector(".spawnX");
      const spawnYEl    = coordBlock.querySelector(".spawnY");
      const launchXEl   = coordBlock.querySelector(".launchX");
      const launchYEl   = coordBlock.querySelector(".launchY");
      const angleLaunchEl = coordBlock.querySelector(".angleLaunch");
      const maxSpeedEl  = coordBlock.querySelector(".maxSpeed");
      const radiusEl    = coordBlock.querySelector(".radius");
      const spawnCoinBtn= coordBlock.querySelector(".spawnCoin");
      const resetSpawnCoinBtn = coordBlock.querySelector(".resetSpawnCoin");
      const resetLeverBtn = coordBlock.querySelector(".resetLever");

      // 状態
      const state = {
        id: config.id,
        angleDeg: 0,
        spawnX: config.spawnX,
        spawnY: config.spawnY,
        launchX: config.launchX,
        launchY: config.launchY,
        launchAngleDeg: config.launchAngleDeg,
        maxLaunchSpeed: config.maxLaunchSpeed,
        launchRadius: config.launchRadius,
        isDragging: false,
        dragStartY: 0,
        dragStartAngle: 0,
        leverEl,
        angleTextEl,
        powerTextEl
      };
      leverStates.push(state);

      function calcPullPower() {
        const normalized = state.angleDeg / REBA_MAX_ANGLE_DEG;
        return Math.pow(normalized, REBA_HEAVINESS_EXPONENT);
      }

      function updateLeverVisual() {
        leverEl.style.transform = `translateX(-50%) rotate(${state.angleDeg}deg)`;
        angleTextEl.textContent = state.angleDeg.toFixed(1);
        powerTextEl.textContent = calcPullPower().toFixed(2);
      }

      function getLaunchDirection() {
        const rad = state.launchAngleDeg * Math.PI / 180;
        return { x: Math.cos(rad), y: Math.sin(rad) };
      }

      function getLaunchPower() {
        return calcPullPower() * state.maxLaunchSpeed;
      }

      function releaseLeverAndLaunch() {
        const power = getLaunchPower();
        if (power <= 0.1) {
          state.angleDeg = 0;
          updateLeverVisual();
          return;
        }
        const dir = getLaunchDirection();
        coins.forEach(c => {
          const dx = c.position.x - state.launchX;
          const dy = c.position.y - state.launchY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < state.launchRadius) {
            const vx = dir.x * power;
            const vy = dir.y * power;
            Body.setVelocity(c, { x: vx, y: vy });
          }
        });
        state.angleDeg = 0;
        updateLeverVisual();
      }

      function startDragLever(y) {
        state.isDragging = true;
        state.dragStartY = y;
        state.dragStartAngle = state.angleDeg;
      }
      function moveDragLever(y) {
        if (!state.isDragging) return;
        const dy = y - state.dragStartY;
        let newAngle = state.dragStartAngle + dy * REBA_DRAG_SENSITIVITY;
        newAngle = Math.max(0, Math.min(REBA_MAX_ANGLE_DEG, newAngle));
        state.angleDeg = newAngle;
        updateLeverVisual();
      }
      function endDragLever() {
        if (!state.isDragging) return;
        state.isDragging = false;
        releaseLeverAndLaunch();
      }

      // レバー UI イベント
      leverEl.addEventListener("mousedown", e => {
        e.preventDefault();
        startDragLever(e.clientY);
      });
      window.addEventListener("mousemove", e => {
        if (!state.isDragging) return;
        e.preventDefault();
        moveDragLever(e.clientY);
      });
      window.addEventListener("mouseup", e => {
        if (!state.isDragging) return;
        e.preventDefault();
        endDragLever();
      });

      leverEl.addEventListener("touchstart", e => {
        e.preventDefault();
        const t = e.touches[0];
        startDragLever(t.clientY);
      }, { passive: false });
      window.addEventListener("touchmove", e => {
        if (!state.isDragging) return;
        e.preventDefault();
        const t = e.touches[0];
        moveDragLever(t.clientY);
      }, { passive: false });
      window.addEventListener("touchend", e => {
        if (!state.isDragging) return;
        e.preventDefault();
        endDragLever();
      }, { passive: false });

      // 入力変更 → state 更新
      function syncInputsToState() {
        state.spawnX        = parseFloat(spawnXEl.value)    || state.spawnX;
        state.spawnY        = parseFloat(spawnYEl.value)    || state.spawnY;
        state.launchX       = parseFloat(launchXEl.value)   || state.launchX;
        state.launchY       = parseFloat(launchYEl.value)   || state.launchY;
        state.launchAngleDeg= parseFloat(angleLaunchEl.value)|| state.launchAngleDeg;
        state.maxLaunchSpeed= parseFloat(maxSpeedEl.value)  || state.maxLaunchSpeed;
        state.launchRadius  = parseFloat(radiusEl.value)    || state.launchRadius;
      }

      [spawnXEl, spawnYEl, launchXEl, launchYEl, angleLaunchEl, maxSpeedEl, radiusEl]
        .forEach(inp => {
          inp.addEventListener("change", syncInputsToState);
        });

      // スポーン位置に10円追加
      spawnCoinBtn.addEventListener("click", () => {
        syncInputsToState();
        addCoinAt(state.spawnX, state.spawnY);
      });

      // スポーン位置リセット → そこに1枚だけ置き直す
      resetSpawnCoinBtn.addEventListener("click", () => {
        syncInputsToState();
        coins.forEach(c => {
          const dx = c.position.x - state.spawnX;
          const dy = c.position.y - state.spawnY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 40) {
            Composite.remove(world, c);
          }
        });
        addCoinAt(state.spawnX, state.spawnY);
      });

      // レバー角度だけリセット
      resetLeverBtn.addEventListener("click", () => {
        state.angleDeg = 0;
        updateLeverVisual();
      });

      updateLeverVisual();
    }

    // レバーを生成
    initialLevers.forEach(cfg => createLeverUIAndLogic(cfg));

    // 初期：レバー1のスポーン位置に 1 枚置いておく
    addCoinAt(initialLevers[0].spawnX, initialLevers[0].spawnY);

    // ============================================================
    // 「飛ばす範囲」を緑円で表示（デバッグレンダラー）
    // ============================================================
    // Matter.Render の beforeRender を使って、円を描画
    (function patchRenderForLaunchAreas() {
      const originalRender = render;
      const _render = originalRender;
      const ctx = _render.context;
      const _renderWorld = Render.world;
      Render.world = function(engine) {
        _renderWorld.call(Render, engine);
        // 範囲を描画
        ctx.save();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(0,255,0,0.7)";
        leverStates.forEach(st => {
          ctx.beginPath();
          ctx.arc(st.launchX, st.launchY, st.launchRadius, 0, Math.PI * 2);
          ctx.stroke();
        });
        ctx.restore();
      };
    })();

    // ============================================================
    // 斜面に応じた「追加の転がり力」
    // ============================================================
    // 接触している床の法線ベクトルから「下向き成分」を見て、
    // それに応じてコインに力を加える。
    Matter.Events.on(engine, "beforeUpdate", () => {
      const pairs = engine.pairs.list;
      for (const pair of pairs) {
        const { bodyA, bodyB, collision } = pair;

        const coin = (bodyA.isStatic ? bodyB : bodyA);
        const other = (coin === bodyA ? bodyB : bodyA);

        if (coin.label !== "Circle Body") continue; // 簡易: コインだけ対象
        if (!other.isStatic) continue; // 静的床のときだけ

        // collision.normal は「A から B へ���法線」なので、向きに注意
        // ここでは、床の法線ベクトルを n とし、重力(0,1)との内積で
        // 「どれだけ下向き成分があるか」を見る。
        const n = collision.normal;
        const dot = n.x * 0 + n.y * 1; // 下向きとの内積

        // dot が +1 に近いほど「真下向きの法線」＝床が真上向き（水平）
        // 床の「下り方向」は、接線ベクトル (t) を使って、重力の成分を投影した方向で求められる。
        // t を ( -n.y, n.x ) として接線を取り、その向きに沿って小さな力を加える。
        const t = { x: -n.y, y: n.x }; // 床に沿う向き（左右どちらか）

        // 重力ベクトル g=(0,1) の t 方向成分: g_t = (g·t) * t
        const gDotT = 0 * t.x + 1 * t.y;
        const slopeAlong = { x: t.x * gDotT, y: t.y * gDotT };

        // これをもとに、コインに力を追加
        const mag = Math.sqrt(slopeAlong.x * slopeAlong.x + slopeAlong.y * slopeAlong.y);
        if (mag > 0) {
          // 下り方向だけ効くように（gDotT > 0 のとき）
          if (gDotT > 0) {
            const fx = slopeAlong.x * SLOPE_BOOST_FACTOR * coin.mass;
            const fy = slopeAlong.y * SLOPE_BOOST_FACTOR * coin.mass;
            Body.applyForce(coin, coin.position, { x: fx, y: fy });
          }
        }
      }
    });

    // ============================================================
    // ウィンドウリサイズ（必要ならリロード）
    // ============================================================
    window.addEventListener("resize", () => {
      // 本格対応するならここで再レイアウトが必要。
      // 必要なら location.reload() を有効化。
      // location.reload();
    });
  </script>
</body>
</html>
