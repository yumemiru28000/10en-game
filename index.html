<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円打ち出しレバー実験</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #world {
      flex: 1;
    }
    #ui {
      padding: 6px 10px;
      background: #111;
      font-size: 13px;
    }
    button {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div id="world"></div>
  <div id="ui">
    <button id="reset">10円をリセット</button>
    レバーをマウスでつかんで下方向へ引いてください（離すと発射）
  </div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    const {
      Engine,
      Render,
      Runner,
      Bodies,
      Body,
      Composite,
      Constraint,
      Vector
    } = Matter;

    const engine = Engine.create();
    const world  = engine.world;

    // 重力（下向き）
    world.gravity.y = 1.0;

    const width  = 600;
    const height = 500;

    const render = Render.create({
      element: document.getElementById('world'),
      engine: engine,
      options: {
        width,
        height,
        wireframes: false,
        background: '#222'
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // --- 基本ステージ（箱、床、斜め床など） ---
    const wallThickness = 40;

    const leftWall = Bodies.rectangle(80, height / 2, wallThickness, height, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    const rightWall = Bodies.rectangle(width - 80, height / 2, wallThickness, height, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    const ceiling = Bodies.rectangle(width / 2, 40, width - 160, 30, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });

    // 少し傾けた床（10円がレバー側へ転がってくるイメージ）
    const floor = Bodies.rectangle(width / 2, height - 40, width - 160, 30, {
      isStatic: true,
      angle: -Math.PI / 40, // わずかに左上がり
      render: { fillStyle: '#555' }
    });

    // 箱の角に置いた斜めの棒（ガイド）
    const cornerBar = Bodies.rectangle(180, height - 120, 160, 12, {
      isStatic: true,
      angle: -Math.PI / 4, // -45度
      render: { fillStyle: '#888' }
    });

    Composite.add(world, [leftWall, rightWall, ceiling, floor, cornerBar]);

    // --- 10円玉 ---
    const COIN_RADIUS = 11;   // 見た目の半径 (px)
    const COIN_MASS   = 0.0055; // 5.5g = 0.0055kg

    let coin = null;

    function createCoin() {
      if (coin) {
        Composite.remove(world, coin);
      }
      // 斜め床の上、少し右寄りから転がってくるように配置
      coin = Bodies.circle(260, height - 160, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: 0.2,
        friction: 0.03,
        frictionAir: 0.001,
        render: {
          fillStyle: '#cc8844',
          strokeStyle: '#e0b46a',
          lineWidth: 2
        }
      });
      Composite.add(world, coin);
    }

    createCoin();

    // --- レバーと打ち出し棒 ---
    // レバーは縦向きで、時計回りに最大約90度回せる
    // レバーの軸位置
    const leverPivot = { x: 120, y: 220 };

    const lever = Bodies.rectangle(leverPivot.x, leverPivot.y - 60, 18, 120, {
      density: 0.002,
      frictionAir: 0.02,
      render: { fillStyle: '#99ccff' }
    });

    // レバーの回転を固定するヒンジ
    const leverHinge = Constraint.create({
      bodyA: lever,
      pointA: { x: 0, y: 60 }, // レバー下端あたり
      pointB: { x: leverPivot.x, y: leverPivot.y },
      stiffness: 1,
      length: 0
    });

    Composite.add(world, [lever, leverHinge]);

    // 打ち出し棒（プランジャー）
    // 10円より少し小さいすき間から飛び出すイメージ
    // 位置は箱の右側の方（レバーとリンクで動く）
    const plunger = Bodies.rectangle(260, height - 130, 60, 10, {
      density: 0.004,
      frictionAir: 0.02,
      render: { fillStyle: '#ffcc66' }
    });

    // プランジャーのスライド用ガイド（縦位置をほぼ制限したいので角度を0で、横だけに近い動き）
    const plungerGuide = Constraint.create({
      bodyA: plunger,
      pointA: { x: 0, y: 0 },
      pointB: { x: 260, y: height - 130 },
      stiffness: 0.9,
      length: 0
    });

    Composite.add(world, [plunger, plungerGuide]);

    // 発射口のすき間を表す、小さな床と天井（棒だけが出る）
    const lowerGap = Bodies.rectangle(260, height - 115, 80, 6, {
      isStatic: true,
      render: { fillStyle: '#777' }
    });
    const upperGap = Bodies.rectangle(260, height - 145, 80, 6, {
      isStatic: true,
      render: { fillStyle: '#777' }
    });
    Composite.add(world, [lowerGap, upperGap]);

    // --- レバーとプランジャーを「リンク」する ---
    // レバー角度 → バネの伸び量(=エネルギー) → プランジャーの「戻り速度」に反映

    let isDraggingLever = false;
    let dragStartAngle = 0;
    let dragStartMouseAngle = 0;

    const MAX_LEVER_ROT = Math.PI / 2; // 約90度
    const MIN_LEVER_ROT = 0;           // 縦向き

    // 現在のバネエネルギー（0～1 程度に正規化）
    let springEnergy = 0;

    // レバーの角度から「バネの伸び」を計算してエネルギーを決める
    function updateSpringFromLever() {
      const currentAngle = lever.angle;
      const stretch = Math.max(0, Math.min(currentAngle, MAX_LEVER_ROT)); // 0～MAX
      // エネルギー ~ 伸び量^2 としてみる（バネエネルギー 1/2 k x^2 のイメージ）
      const energy = (stretch / MAX_LEVER_ROT) ** 2;
      springEnergy = energy;
    }

    // レバー角度からプランジャーの引き量を決める（単純な線形マッピング）
    function updatePlungerFromLever() {
      const t = Math.max(0, Math.min(lever.angle / MAX_LEVER_ROT, 1));
      // プランジャー基準位置から最大 80px くらい後ろへ引く
      const maxBack = 80;
      const baseX = 260 + maxBack * t;

      Body.setPosition(plunger, {
        x: baseX,
        y: height - 130
      });
      // 角度は常に水平方向
      Body.setAngle(plunger, 0);
      Body.setAngularVelocity(plunger, 0);
      Body.setVelocity(plunger, { x: 0, y: 0 });
    }

    // レバーを自然に戻す＋バネエネルギーでプランジャーを押し出す処理
    function applySpringReturn() {
      if (isDraggingLever) return; // ドラッグ中はバネ制御しない

      const angle = lever.angle;

      if (angle <= 0.001 && Math.abs(lever.angularVelocity) < 0.01) {
        // ほぼ基準位置
        Body.setAngle(lever, 0);
        Body.setAngularVelocity(lever, 0);
        return;
      }

      // バネトルク: angle が大きいほど強く戻す
      const k = 0.15 + springEnergy * 0.8; // 引き具合でバネの強さが変わるイメージ
      const damping = 0.12;

      const torque = -k * angle - damping * lever.angularVelocity;
      // トルクをそのまま角加速度に近似的に適用
      lever.torque = torque;

      // プランジャーにもそれに応じた速度を与える
      const t = Math.max(0, Math.min(angle / MAX_LEVER_ROT, 1));
      const maxBack = 80;
      const currentBack = maxBack * t;
      const desiredX = 260 + currentBack;

      // angle が大きいほど押し出し速度も大きく
      const pushPower = springEnergy * 40; // 「引き具合によって戻るスピードが変わる」部分
      const vx = -pushPower * t;          // レバーが戻る方向に合わせて左向き

      Body.setVelocity(plunger, { x: vx, y: 0 });

      // 実際の位置はエンジンに任せるが、変にぶれないように少しガイド
      Body.applyForce(plunger, plunger.position, {
        x: vx * 0.0005,
        y: 0
      });
    }

    // --- マウス操作でレバーをドラッグ ---
    const canvas = render.canvas;

    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX - rect.left) * (canvas.width / rect.width),
        y: (evt.clientY - rect.top)  * (canvas.height / rect.height)
      };
    }

    canvas.addEventListener('mousedown', (evt) => {
      const pos = getMousePos(evt);
      const dx = pos.x - lever.position.x;
      const dy = pos.y - lever.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      // レバーをつかんだかどうか（簡易的に距離で判定）
      if (dist < 80) {
        isDraggingLever = true;
        dragStartAngle = lever.angle;
        const vec = { x: pos.x - leverPivot.x, y: pos.y - leverPivot.y };
        dragStartMouseAngle = Math.atan2(vec.y, vec.x);
      }
    });

    canvas.addEventListener('mousemove', (evt) => {
      if (!isDraggingLever) return;
      const pos = getMousePos(evt);
      const vec = { x: pos.x - leverPivot.x, y: pos.y - leverPivot.y };
      const nowMouseAngle = Math.atan2(vec.y, vec.x);

      // ピボット基準の角度差を計算
      let delta = nowMouseAngle - dragStartMouseAngle;

      // 初期レバーはだいたい縦(=約90度)だが、ここでは「下方向へ90度まで」しか動けないように制限
      let targetAngle = dragStartAngle + delta;

      // 0(縦)～MAX_LEVER_ROT(90度) の範囲にクランプ
      targetAngle = Math.max(MIN_LEVER_ROT, Math.min(MAX_LEVER_ROT, targetAngle));

      Body.setAngle(lever, targetAngle);
      Body.setAngularVelocity(lever, 0);

      updateSpringFromLever();
      updatePlungerFromLever();
    });

    canvas.addEventListener('mouseup', () => {
      if (isDraggingLever) {
        isDraggingLever = false;
        // ここからは applySpringReturn() に任せる
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (isDraggingLever) {
        isDraggingLever = false;
      }
    });

    // --- 毎フレームの更新 ---
    Matter.Events.on(engine, 'beforeUpdate', () => {
      applySpringReturn();
    });

    // --- UI: 10円をリセット ---
    document.getElementById('reset').addEventListener('click', () => {
      createCoin();
      // レバーとプランジャーも初期状態に戻す
      Body.setAngle(lever, 0);
      Body.setAngularVelocity(lever, 0);
      springEnergy = 0;
      updatePlungerFromLever();
    });

    // 初期位置合わせ
    Body.setAngle(lever, 0);
    updateSpringFromLever();
    updatePlungerFromLever();
  </script>
</body>
</html>
