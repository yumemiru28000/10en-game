<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>10円 vs ren輪郭 + kaisi（画像サイズ優先 + 縁取り棒）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
    }
    #info {
      font-size: 12px;
      margin-bottom: 4px;
    }
    #canvasWrapper {
      position: relative;
      border: 1px solid #555;
      background: #000;
    }
    #controlPanel {
      font-size: 12px;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div id="info">
    ・map.png / ren.png / kaisi.png の実サイズをそのままキャンバスに使用（拡大縮小なし）。<br>
    ・ren.png の黒と背景の「境目」ピクセルをすべて抽出し、その輪郭に沿って短い棒（線分チェーン）を自動生成。<br>
    ・kaisi.png の黒いピクセルからランダムに10円（半径32px）を生成。<br>
    ・10円は、ren の縁取り棒の上をサブステップ＋距離ベース判定で転がります。
  </div>

  <div id="canvasWrapper">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div id="controlPanel">
    重力: <input id="gravityInput" type="number" step="0.1" value="0.5">
    摩擦: <input id="frictionInput" type="number" step="0.01" value="0.02">
    静止閾値: <input id="staticInput" type="number" step="0.01" value="0.02">
    <button id="resetCoinBtn">10円リセット（kaisi黒から）</button>
    <button id="playPauseBtn">一時停止</button>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gravityInput = document.getElementById("gravityInput");
    const frictionInput = document.getElementById("frictionInput");
    const staticInput = document.getElementById("staticInput");
    const resetCoinBtn = document.getElementById("resetCoinBtn");
    const playPauseBtn = document.getElementById("playPauseBtn");

    const MAP_URL   = "map.png";
    const REN_URL   = "ren.png";
    const KAISI_URL = "kaisi.png";

    const bgImage    = new Image();
    const renImage   = new Image();
    const kaisiImage = new Image();
    let imagesLoaded = 0;

    bgImage.src    = MAP_URL;
    renImage.src   = REN_URL;
    kaisiImage.src = KAISI_URL;

    bgImage.onload    = onImageLoaded;
    renImage.onload   = onImageLoaded;
    kaisiImage.onload = onImageLoaded;

    const renCanvas   = document.createElement("canvas");
    const renCtx      = renCanvas.getContext("2d");
    let renData       = null;

    const kaisiCanvas = document.createElement("canvas");
    const kaisiCtx    = kaisiCanvas.getContext("2d");
    let kaisiData     = null;
    let startPixels   = [];

    let GRAVITY          = parseFloat(gravityInput.value) || 0.5;
    let SLOPE_FRICTION   = parseFloat(frictionInput.value) || 0.02;
    let STATIC_THRESHOLD = parseFloat(staticInput.value)   || 0.02;

    gravityInput.addEventListener("input", () => {
      GRAVITY = parseFloat(gravityInput.value) || GRAVITY;
    });
    frictionInput.addEventListener("input", () => {
      SLOPE_FRICTION = parseFloat(frictionInput.value) || SLOPE_FRICTION;
    });
    staticInput.addEventListener("input", () => {
      STATIC_THRESHOLD = parseFloat(staticInput.value) || STATIC_THRESHOLD;
    });

    const coin = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      r: 32
    };

    const slopes = []; // 縁取りから生成された短い棒たち

    let paused = false;
    playPauseBtn.addEventListener("click", () => {
      paused = !paused;
      playPauseBtn.textContent = paused ? "再生" : "一時停止";
    });

    resetCoinBtn.addEventListener("click", () => {
      resetCoinFromKaisi();
    });

    function onImageLoaded() {
      imagesLoaded++;
      if (imagesLoaded === 3) {
        initAfterImagesLoaded();
      }
    }

    function initAfterImagesLoaded() {
      const w = bgImage.naturalWidth  || bgImage.width;
      const h = bgImage.naturalHeight || bgImage.height;
      canvas.width  = w;
      canvas.height = h;

      renCanvas.width  = w;
      renCanvas.height = h;
      renCtx.drawImage(renImage, 0, 0, w, h);
      renData = renCtx.getImageData(0, 0, w, h);

      kaisiCanvas.width  = w;
      kaisiCanvas.height = h;
      kaisiCtx.drawImage(kaisiImage, 0, 0, w, h);
      kaisiData = kaisiCtx.getImageData(0, 0, w, h);

      extractOutlineSlopesFromRen();
      extractStartPixelsFromKaisi();

      resetCoinFromKaisi();
      loop();
    }

    function isBlackAt(imgData, x, y) {
      if (!imgData) return false;
      const ix = Math.floor(x), iy = Math.floor(y);
      if (ix < 0 || iy < 0 || ix >= imgData.width || iy >= imgData.height) return false;
      const idx = (iy * imgData.width + ix) * 4;
      const r = imgData.data[idx], g = imgData.data[idx+1], b = imgData.data[idx+2], a = imgData.data[idx+3];
      return a > 20 && r < 40 && g < 40 && b < 40;
    }

    // 黒→背景の「境界ドット」を検出し、その輪郭に沿って棒チェーンを作る
    function extractOutlineSlopesFromRen() {
      slopes.length = 0;
      if (!renData) return;

      const w = renData.width;
      const h = renData.height;

      // 1. 黒マップ & 境界マップ
      const isBlackMap   = new Uint8Array(w * h);
      const isBorderMap  = new Uint8Array(w * h);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = y*w + x;
          if (isBlackAt(renData, x, y)) {
            isBlackMap[idx] = 1;
          }
        }
      }

      const neigh4 = [
        [ 1,  0], [-1,  0],
        [ 0,  1], [ 0, -1]
      ];

      // 黒で、かつ4近傍のどこかが非黒なら「境界」
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = y*w + x;
          if (!isBlackMap[idx]) continue;
          let isBorder = false;
          for (const [dx, dy] of neigh4) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= w || ny >= h) {
              isBorder = true;
              break;
            }
            const nidx = ny*w + nx;
            if (!isBlackMap[nidx]) {
              isBorder = true;
              break;
            }
          }
          if (isBorder) {
            isBorderMap[idx] = 1;
          }
        }
      }

      // 2. 境界ドットの連結成分（輪郭）ごとに棒チェーン化
      const visited = new Uint8Array(w*h);
      const neigh8 = [
        [ 1,  0], [-1,  0],
        [ 0,  1], [ 0, -1],
        [ 1,  1], [ 1, -1],
        [-1,  1], [-1, -1]
      ];

      function bfsOutline(sx, sy) {
        const q = [[sx, sy]];
        const pixels = [];
        visited[sy*w + sx] = 1;
        while (q.length) {
          const [x, y] = q.shift();
          pixels.push({ x, y });
          for (const [dx, dy] of neigh8) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
            const idx = ny*w + nx;
            if (!isBorderMap[idx] || visited[idx]) continue;
            visited[idx] = 1;
            q.push([nx, ny]);
          }
        }
        return pixels;
      }

      const MIN_OUTLINE_PIXELS = 10;   // 輪郭ノイズ除去
      const SEGMENT_STEP       = 6;    // 何ドットごとに折れ点を作るか

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = y*w + x;
          if (!isBorderMap[idx] || visited[idx]) continue;
          const outline = bfsOutline(x, y);
          if (outline.length < MIN_OUTLINE_PIXELS) continue; // 小さいノイズ輪郭は無視

          // 輪郭のピクセル配列 outline を、順番近似としてそのまま使う
          // 一定ステップごとに点を間引きして短い線分チェーンにする
          for (let i = 0; i < outline.length - SEGMENT_STEP; i += SEGMENT_STEP) {
            const p1 = outline[i];
            const p2 = outline[i + SEGMENT_STEP];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len < 4) continue; // 短すぎるセグメントは無視
            slopes.push({
              x1: p1.x,
              y1: p1.y,
              x2: p2.x,
              y2: p2.y
            });
          }
        }
      }

      console.log("ren 縁取りから生成された棒の本数:", slopes.length);
    }

    function extractStartPixelsFromKaisi() {
      startPixels = [];
      if (!kaisiData) return;
      const w = kaisiData.width;
      const h = kaisiData.height;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          if (isBlackAt(kaisiData, x, y)) {
            startPixels.push({ x, y });
          }
        }
      }
      console.log("kaisi 黒ピクセル数:", startPixels.length);
    }

    function resetCoinFromKaisi() {
      if (!startPixels.length) {
        coin.x = canvas.width/2;
        coin.y = 50;
      } else {
        const idx = Math.floor(Math.random() * startPixels.length);
        const { x, y } = startPixels[idx];
        coin.x = x;
        coin.y = y - coin.r * 0.3;
      }
      coin.vx = 0;
      coin.vy = 0;
    }

    function updatePhysics() {
      if (paused) return;
      if (!renData) return;

      const SUB_STEPS = 4;
      const dt = 1 / SUB_STEPS;

      for (let i = 0; i < SUB_STEPS; i++) {
        coin.vy += GRAVITY * dt;
        coin.x += coin.vx * dt;
        coin.y += coin.vy * dt;

        resolveCollisionsWithSlopes(dt);
      }

      const bounce = 0.3;
      if (coin.x - coin.r < 0) {
        coin.x = coin.r;
        if (coin.vx < 0) coin.vx *= -bounce;
      }
      if (coin.x + coin.r > canvas.width) {
        coin.x = canvas.width - coin.r;
        if (coin.vx > 0) coin.vx *= -bounce;
      }
      if (coin.y - coin.r < 0) {
        coin.y = coin.r;
        if (coin.vy < 0) coin.vy *= -bounce;
      }
      if (coin.y + coin.r > canvas.height) {
        coin.y = canvas.height - coin.r;
        if (coin.vy > 0) coin.vy *= -bounce;
      }
    }

    function resolveCollisionsWithSlopes(dt) {
      for (const s of slopes) {
        const { px, py, d } = closestPointOnSegment(
          s.x1, s.y1, s.x2, s.y2,
          coin.x, coin.y
        );
        if (d >= coin.r) continue;

        const dx = s.x2 - s.x1;
        const dy = s.y2 - s.y1;
        const len = Math.sqrt(dx*dx + dy*dy) || 1;
        const tx = dx / len;
        const ty = dy / len;
        const nx = -ty;
        const ny =  tx;

        const penetration = coin.r - d;
        coin.x += nx * (penetration + 0.2);
        coin.y += ny * (penetration + 0.2);

        const vpx = coin.vx;
        const vpy = coin.vy;
        const v_parallel = vpx * tx + vpy * ty;
        let v_normal   = vpx * nx + vpy * ny;

        v_normal = 0;

        const g_parallel = GRAVITY * ty * dt;
        let new_v_parallel = v_parallel + g_parallel;

        if (Math.abs(g_parallel) < STATIC_THRESHOLD * dt &&
            Math.abs(v_parallel) < STATIC_THRESHOLD) {
          new_v_parallel = 0;
        } else {
          new_v_parallel *= (1 - SLOPE_FRICTION);
        }

        coin.vx = new_v_parallel * tx + v_normal * nx;
        coin.vy = new_v_parallel * ty + v_normal * ny;
      }
    }

    function closestPointOnSegment(ax, ay, bx, by, cx, cy) {
      const abx = bx - ax;
      const aby = by - ay;
      const acx = cx - ax;
      const acy = cy - ay;
      const abLen2 = abx*abx + aby*aby || 1;
      let t = (acx * abx + acy * aby) / abLen2;
      t = Math.max(0, Math.min(1, t));
      const px = ax + abx * t;
      const py = ay + aby * t;
      const dx = cx - px;
      const dy = cy - py;
      const d = Math.sqrt(dx*dx + dy*dy);
      return { px, py, d, t };
    }

    function draw() {
      if (!bgImage.complete) return;

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);

      // ren 縁取りから作られた棒
      ctx.strokeStyle = "#44aaff";
      ctx.lineWidth = 2;
      for (const s of slopes) {
        ctx.beginPath();
        ctx.moveTo(s.x1, s.y1);
        ctx.lineTo(s.x2, s.y2);
        ctx.stroke();
      }

      // 10円
      ctx.save();
      ctx.translate(coin.x, coin.y);
      ctx.fillStyle = "#cc8844";
      ctx.beginPath();
      ctx.arc(0,0,coin.r,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#5b3a10";
      ctx.font = "bold 16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("10",0,0);
      ctx.restore();
    }

    function loop() {
      requestAnimationFrame(loop);
      if (!renData || !kaisiData) return;
      updatePhysics();
      draw();
    }
  </script>
</body>
</html>
