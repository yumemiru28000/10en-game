<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円ゲーム レバー発射実験（重さ・角度パラメータ調整版）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      overflow: hidden;
    }

    #uiPanel {
      width: 180px;
      background: #111;
      border-right: 1px solid #333;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 12px;
    }

    #leverArea {
      position: relative;
      width: 160px;
      height: 160px;
      margin: 0 auto;
      border: 1px solid #444;
      background: #181818;
      border-radius: 4px;
      touch-action: none;
    }

    /* レバー UI （「L」の形） */
    #lever {
      position: absolute;
      width: 12px;       /* 縦棒の太さ */
      height: 90px;      /* 縦棒の長さ */
      background: #ccc;
      left: 50%;
      bottom: 20px;
      transform-origin: 50% 100%; /* 下端を支点 */
      transform: translateX(-50%) rotate(0deg);
      cursor: grab;
    }
    #lever:active {
      cursor: grabbing;
    }

    /* 「L」の横棒部分を疑似要素で表現 */
    #lever::after {
      content: "";
      position: absolute;
      width: 32px;   /* 横棒の長さ */
      height: 12px;  /* 横棒の太さ */
      background: #ccc;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
    }

    #leverLabel {
      position: absolute;
      left: 4px;
      bottom: 4px;
      font-size: 10px;
      color: #aaa;
    }

    #leverInfo {
      font-size: 12px;
      line-height: 1.5;
    }

    #world {
      flex: 1;
    }

    button {
      font-size: 12px;
      padding: 4px 8px;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #444;
    }
    input[type="number"] {
      width: 70px;
      background: #222;
      border: 1px solid #555;
      color: #eee;
      padding: 2px 4px;
      border-radius: 3px;
    }
    label {
      font-size: 11px;
      display: block;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div id="uiPanel">
    <div id="leverArea">
      <div id="lever"></div>
      <div id="leverLabel">レバー</div>
    </div>
    <div id="leverInfo">
      レバー角度: <span id="angleText">0</span>°<br>
      引き具合(0～1): <span id="powerText">0.00</span>
    </div>

    <label>
      重力:
      <input id="gravity" type="number" step="0.1" value="1.0">
    </label>

    <label>
      発射角度(° 右=0, 上=-90):
      <input id="launchAngleInput" type="number" step="1" value="-45">
    </label>

    <label>
      引きにくさ(大きいほど後半が重い):
      <input id="nonlinearityInput" type="number" step="0.5" value="3">
    </label>

    <div style="margin-top:4px;">
      <button id="addCoin">10円を置く</button>
      <button id="resetWorld">リセット</button>
    </div>

    <div style="font-size:11px; color:#aaa; margin-top:6px;">
      操作説明:<br>
      ・レバーをドラッグで時計回り最大90°まで回す<br>
      ・離した瞬間、近くの10円を指定角度へ発射<br>
      ・「引きにくさ」を上げると、後半はほとんど動かなくなる
    </div>
  </div>

  <div id="world"></div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ================== 調整用パラメータ =====================
    // 最大レバー角度（度）
    const MAX_LEVER_ANGLE_DEG = 90;

    // 「引きにくさ」の初期値（UI からも変更可）
    // 大きくするほど、後半はほとんど角度が増えなくなる
    let PULL_NONLINEARITY = 3.0;

    // マウス移動 → 生角度変化への感度（線形部分）
    const PULL_SENSITIVITY = 0.5; // 大きくすると少しの移動でたくさん回る

    // 発射角度（度、右向き0°、上向き -90°） UI から変更可
    let LAUNCH_ANGLE_DEG = -45;

    // 最大発射速度（角度が MAX のときの速度の大きさ）
    const MAX_LAUNCH_SPEED = 25;

    // =========================================================
    // Matter.js 基本セットアップ
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const Runner = Matter.Runner;
    const Bodies = Matter.Bodies;
    const Composite = Matter.Composite;
    const Body = Matter.Body;

    const engine = Engine.create();
    const world  = engine.world;
    engine.world.gravity.y = 1.0;

    const canvasWidth  = window.innerWidth - 180; // UIパネル分
    const canvasHeight = window.innerHeight;

    const render = Render.create({
      element: document.getElementById('world'),
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        wireframes: false,
        background: '#222'
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // ================== フィールド構造 =======================
    const thickness = 40;

    const leftWall = Bodies.rectangle(20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    const rightWall = Bodies.rectangle(canvasWidth - 20, canvasHeight / 2, thickness, canvasHeight, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    const ceiling = Bodies.rectangle(canvasWidth / 2, 20, canvasWidth, thickness, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });

    // 右下の斜め床 + 角の棒
    const floorAngle = -Math.PI / 8;
    const floorLength = 500;

    const slopedFloor = Bodies.rectangle(
      canvasWidth - 260,
      canvasHeight - 60,
      floorLength,
      20,
      {
        isStatic: true,
        angle: floorAngle,
        render: { fillStyle: '#666' }
      }
    );

    const cornerPost = Bodies.rectangle(
      canvasWidth - 350,
      canvasHeight - 150,
      20,
      80,
      {
        isStatic: true,
        render: { fillStyle: '#888' }
      }
    );

    Composite.add(world, [leftWall, rightWall, ceiling, slopedFloor, cornerPost]);

    // ================== 10円玉 ==============================
    const COIN_RADIUS = 11;
    const COIN_MASS   = 0.0055;

    function createCoin(x, y) {
      return Bodies.circle(x, y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: 0.3,
        friction: 0.1,
        frictionAir: 0.002,
        render: {
          fillStyle: '#cc8844',
          strokeStyle: '#ddbb77',
          lineWidth: 2
        }
      });
    }

    const coins = [];

    function addCoinAt(x, y) {
      const c = createCoin(x, y);
      coins.push(c);
      Composite.add(world, c);
      return c;
    }

    // 発射台の位置
    const launchBaseX = 240;
    const launchBaseY = canvasHeight - 220;
    addCoinAt(launchBaseX, launchBaseY);

    // 「10円より小さいすき間」風のブロック
    const blockThickness = 20;
    const baseBlockWidth = 80;

    const slotUpper = Bodies.rectangle(
      launchBaseX,
      launchBaseY - COIN_RADIUS - 5,
      baseBlockWidth,
      blockThickness,
      { isStatic: true, render: { fillStyle: '#555' } }
    );
    const slotLower = Bodies.rectangle(
      launchBaseX,
      launchBaseY + COIN_RADIUS + 5,
      baseBlockWidth,
      blockThickness,
      { isStatic: true, render: { fillStyle: '#555' } }
    );
    const slotLeftWall = Bodies.rectangle(
      launchBaseX - baseBlockWidth / 2 + 10,
      launchBaseY,
      20,
      COIN_RADIUS * 4,
      { isStatic: true, render: { fillStyle: '#555' } }
    );

    Composite.add(world, [slotUpper, slotLower, slotLeftWall]);

    // ================== レバー UI ロジック ===================
    const leverEl = document.getElementById('lever');
    const angleTextEl = document.getElementById('angleText');
    const powerTextEl = document.getElementById('powerText');
    const gravityInput = document.getElementById('gravity');
    const launchAngleInput = document.getElementById('launchAngleInput');
    const nonlinearityInput = document.getElementById('nonlinearityInput');
    const addCoinBtn = document.getElementById('addCoin');
    const resetWorldBtn = document.getElementById('resetWorld');

    // 表示上のレバー角度 [度]（0〜MAX_LEVER_ANGLE_DEG）
    let leverAngleDeg = 0;

    // ドラッグ中フラグ
    let isDraggingLever = false;
    let dragStartY = 0;
    let dragStartProgress = 0;  // 「内部の進み具合（0〜1）」の開始値

    // 内部の「進み具合（0〜1）」 → 表示角度への変換
    // 重く感じさせるための非線形マッピング
    function progressToAngle(progress) {
      // 0〜1 の progress を、非線形に変換
      // p' = 1 - (1 - p)^(n)  (n が大きいほど後半が伸びにくい)
      const n = PULL_NONLINEARITY;
      const mapped = 1 - Math.pow(1 - progress, n);
      return mapped * MAX_LEVER_ANGLE_DEG;
    }

    // 表示角度 → 内部進み具合（0〜1）への逆変換
    function angleToProgress(angleDeg) {
      const a = Math.max(0, Math.min(MAX_LEVER_ANGLE_DEG, angleDeg));
      const ratio = a / MAX_LEVER_ANGLE_DEG;
      // ratio = 1 - (1 - p)^n → (1 - p)^n = 1 - ratio
      // → 1 - p = (1 - ratio)^(1/n) → p = 1 - (1 - ratio)^(1/n)
      const n = PULL_NONLINEARITY;
      const p = 1 - Math.pow(1 - ratio, 1 / n);
      return p;
    }

    // 現在の角度を UI 更新
    function updateLeverVisual() {
      leverEl.style.transform = `translateX(-50%) rotate(${leverAngleDeg.toFixed(2)}deg)`;
      angleTextEl.textContent = leverAngleDeg.toFixed(1);

      // 引き具合（内部 progress 自体を表示）
      const progress = angleToProgress(leverAngleDeg);
      powerTextEl.textContent = progress.toFixed(2);
    }

    // レバー位置 → 発射パワー（速度の大きさ）に変換
    // 「打ち出す速度自体は角度に比例」のままにしてある
    function getLaunchPower() {
      const angleRatio = leverAngleDeg / MAX_LEVER_ANGLE_DEG; // 0〜1
      const speed = angleRatio * MAX_LAUNCH_SPEED;
      return speed;
    }

    // 発射方向を LAUNCH_ANGLE_DEG から計算
    function getLaunchDirection() {
      const rad = LAUNCH_ANGLE_DEG * Math.PI / 180;
      return {
        x: Math.cos(rad),
        y: Math.sin(rad)
      };
    }

    // レバーを離したときに発射
    function releaseLeverAndLaunch() {
      const power = getLaunchPower();
      if (power <= 0.1) {
        // ほとんど引いていないときは何もしない
        leverAngleDeg = 0;
        updateLeverVisual();
        return;
      }

      const dir = getLaunchDirection();

      // 発射位置の近くにいるコインを探す
      const launchRadius = 30;
      coins.forEach(c => {
        const dx = c.position.x - launchBaseX;
        const dy = c.position.y - launchBaseY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < launchRadius) {
          const vx = dir.x * power;
          const vy = dir.y * power;
          Body.setVelocity(c, { x: vx, y: vy });
        }
      });

      // レバーを一気に戻す
      leverAngleDeg = 0;
      updateLeverVisual();
    }

    // レバーのドラッグ開始
    function startDragLever(startClientY) {
      isDraggingLever = true;
      dragStartY = startClientY;
      dragStartProgress = angleToProgress(leverAngleDeg); // 現在角度を progress に変換
    }

    // レバーのドラッグ移動
    function moveDragLever(currentClientY) {
      if (!isDraggingLever) return;
      const dy = currentClientY - dragStartY;

      // まず「線形な仮の角度増加」を考える
      const deltaAngleLinear = dy * PULL_SENSITIVITY; // 下へ動かすと正（時計回り）
      const newAngleLinear = dragStartProgress * MAX_LEVER_ANGLE_DEG + deltaAngleLinear;

      // 線形角度を 0〜MAX にクランプしてから、それを角度→progress→非線形で角度に戻す
      const clampedLinearAngle = Math.max(0, Math.min(MAX_LEVER_ANGLE_DEG, newAngleLinear));
      let baseProgress = clampedLinearAngle / MAX_LEVER_ANGLE_DEG; // 線形の進み具合(0〜1)
      // ここで「後半が重い」ように再マッピング
      // → 最終的な表示角度は progressToAngle(baseProgress)
      leverAngleDeg = progressToAngle(baseProgress);
      updateLeverVisual();
    }

    function endDragLever() {
      if (!isDraggingLever) return;
      isDraggingLever = false;
      releaseLeverAndLaunch();
    }

    // マウスイベント
    leverEl.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startDragLever(e.clientY);
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDraggingLever) return;
      e.preventDefault();
      moveDragLever(e.clientY);
    });

    window.addEventListener('mouseup', (e) => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    });

    // タッチイベント
    leverEl.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      startDragLever(t.clientY);
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
      if (!isDraggingLever) return;
      e.preventDefault();
      const t = e.touches[0];
      moveDragLever(t.clientY);
    }, { passive: false });

    window.addEventListener('touchend', (e) => {
      if (!isDraggingLever) return;
      e.preventDefault();
      endDragLever();
    }, { passive: false });

    updateLeverVisual();

    // ================== UI コントロール =======================
    gravityInput.addEventListener('input', (e) => {
      const g = parseFloat(e.target.value) || 0;
      engine.world.gravity.y = g;
    });

    launchAngleInput.addEventListener('input', (e) => {
      const a = parseFloat(e.target.value);
      if (!isNaN(a)) {
        LAUNCH_ANGLE_DEG = a;
      }
    });

    nonlinearityInput.addEventListener('input', (e) => {
      const n = parseFloat(e.target.value);
      if (!isNaN(n) && n > 0) {
        PULL_NONLINEARITY = n;
        // パラメータが変わったので、現在の角度から再描画
        updateLeverVisual();
      }
    });

    addCoinBtn.addEventListener('click', () => {
      const x = launchBaseX + (Math.random() * 20 - 10);
      const y = launchBaseY + (Math.random() * 10 - 5);
      addCoinAt(x, y);
    });

    resetWorldBtn.addEventListener('click', () => {
      coins.forEach(c => Composite.remove(world, c));
      coins.length = 0;
      addCoinAt(launchBaseX, launchBaseY);
      leverAngleDeg = 0;
      updateLeverVisual();
    });
  </script>
</body>
</html>
