<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>10円ゲーム レバー付き実験スペース</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* 左側：レバーUI / 右側：物理ワールド */
    #leftPanel {
      width: 160px;
      background: #181818;
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
    }

    #worldContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #world {
      flex: 1;
    }

    #uiBottom {
      padding: 6px 10px;
      background: #181818;
      font-size: 13px;
      border-top: 1px solid #333;
    }

    button {
      margin-right: 8px;
      margin-bottom: 4px;
      font-size: 13px;
    }

    /* レバーUI本体 */
    #leverArea {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      user-select: none;
    }

    #leverLabel {
      margin-bottom: 4px;
      font-size: 14px;
    }

    /* レール */
    #leverTrack {
      width: 40px;
      height: 200px;
      border-radius: 20px;
      background: #222;
      border: 2px solid #444;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 0 6px #000;
    }

    /* レバーつまみ（縦に動かすだけのUIボタン） */
    #leverKnob {
      width: 36px;
      height: 40px;
      border-radius: 18px;
      background: linear-gradient(#555, #333);
      border: 1px solid #777;
      position: absolute;
      left: 2px;
      /* 初期位置：一番上=0% */
      top: 2px;
      cursor: grab;
      box-shadow: 0 0 4px rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #eee;
      font-size: 12px;
    }

    #leverKnob.dragging {
      cursor: grabbing;
      background: linear-gradient(#777, #444);
    }

    #leverStrength {
      margin-top: 6px;
      font-size: 12px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <!-- 左：レバー＆説明 -->
  <div id="leftPanel">
    <div><strong>10円レバー発射実験</strong></div>
    <div style="font-size:12px; margin-top:4px;">
      1. 10円を投入<br>
      2. レバーを下に引く<br>
      3. レバーから指を離すと発射
    </div>

    <div id="leverArea">
      <div id="leverLabel">レバー</div>
      <div id="leverTrack">
        <div id="leverKnob">引く</div>
      </div>
      <div id="leverStrength">引き具合: 0%</div>
    </div>

    <div style="margin-top:12px; font-size:12px;">
      <button id="addCoinBtn">10円を上から追加</button><br>
      <button id="clearBtn">コインを全部消す</button>
    </div>
  </div>

  <!-- 右：物理ワールド -->
  <div id="worldContainer">
    <div id="world"></div>
    <div id="uiBottom">
      重力: <input id="gravity" type="number" step="0.1" value="1" style="width:60px;"> (下向き)
    </div>
  </div>

  <!-- Matter.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ===== Matter.js セットアップ =====
    const Engine   = Matter.Engine;
    const Render   = Matter.Render;
    const Runner   = Matter.Runner;
    const Bodies   = Matter.Bodies;
    const Composite = Matter.Composite;
    const Body     = Matter.Body;
    const Vector   = Matter.Vector;

    const engine = Engine.create();
    const world  = engine.world;
    engine.world.gravity.y = 1.0;

    const WORLD_WIDTH  = 600;
    const WORLD_HEIGHT = 600;

    const render = Render.create({
      element: document.getElementById('world'),
      engine: engine,
      options: {
        width: WORLD_WIDTH,
        height: WORLD_HEIGHT,
        wireframes: false,
        background: '#111'
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // ===== 実験スペースの形 =====
    // 外枠：右下に向かって床を斜めにする
    const wallThickness = 40;

    // 左壁・右壁・上壁
    const leftWall = Bodies.rectangle(80, WORLD_HEIGHT/2, wallThickness, WORLD_HEIGHT, {
      isStatic: true,
      render: { fillStyle: '#333' }
    });
    const rightWall = Bodies.rectangle(WORLD_WIDTH-40, WORLD_HEIGHT/2, wallThickness, WORLD_HEIGHT, {
      isStatic: true,
      render: { fillStyle: '#333' }
    });
    const topWall = Bodies.rectangle(WORLD_WIDTH/2, 40, WORLD_WIDTH-80, wallThickness, {
      isStatic: true,
      render: { fillStyle: '#333' }
    });

    // 斜め床：左上から右下へ
    const slope = Bodies.rectangle(
      WORLD_WIDTH/2,
      WORLD_HEIGHT-100,
      WORLD_WIDTH-200,
      30,
      {
        isStatic: true,
        angle: -Math.PI/12, // 少し右下に傾斜
        render: { fillStyle: '#555' }
      }
    );

    // 右下の角に、棒が出る「穴」を作るような壁
    // 小さな隙間(コインより少し小さい)を空ける感じで2つのブロックで囲う
    const holeBlock1 = Bodies.rectangle(WORLD_WIDTH-120, WORLD_HEIGHT-80, 20, 80, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    const holeBlock2 = Bodies.rectangle(WORLD_WIDTH-60, WORLD_HEIGHT-40, 100, 20, {
      isStatic: true,
      render: { fillStyle: '#444' }
    });
    // 実際の「隙間」は、この2つの間にある目に見えないスペースだと考える

    Composite.add(world, [leftWall, rightWall, topWall, slope, holeBlock1, holeBlock2]);

    // ===== コイン(10円玉) =====
    const COIN_RADIUS = 11;
    const COIN_MASS   = 0.0055;

    const coins = [];

    function createCoin(x, y) {
      const coin = Bodies.circle(x, y, COIN_RADIUS, {
        mass: COIN_MASS,
        restitution: 0.3,
        friction: 0.05,
        frictionAir: 0.001,
        render: {
          fillStyle: '#cc8844',
          strokeStyle: '#ddbb77',
          lineWidth: 2
        }
      });
      coins.push(coin);
      Composite.add(world, coin);
      return coin;
    }

    // 初期状態：左上から1枚転がす
    createCoin(140, 80);

    // ===== 発射棒（コインより細い棒）=====
    // 「隙間」から右方向に飛び出すイメージ
    const LAUNCH_BAR_LENGTH = 80;
    const LAUNCH_BAR_THICK  = 8;

    // 発射位置（隙間の中心あたり）
    const LAUNCH_ORIGIN = {
      x: WORLD_WIDTH - 115,
      y: WORLD_HEIGHT - 75
    };

    // 発射棒はふだんは「穴の中（短く）」に収納されているニュアンスを出すため、
    // 物理ボディ自体はかなり短く作っておき、発射時に一瞬だけ速度を与える。
    const launchBar = Bodies.rectangle(
      LAUNCH_ORIGIN.x,
      LAUNCH_ORIGIN.y,
      LAUNCH_BAR_LENGTH,
      LAUNCH_BAR_THICK,
      {
        isStatic: false,
        density: 0.03,
        friction: 0.01,
        frictionAir: 0.02,
        restitution: 0.1,
        collisionFilter: {
          category: 0x0002
        },
        render: {
          fillStyle: '#888'
        }
      }
    );

    // 発射棒はある程度、その場に戻ってきやすいようにスプリング拘束しておいてもいい
    const constraint = Matter.Constraint.create({
      bodyA: launchBar,
      pointB: { x: LAUNCH_ORIGIN.x - 20, y: LAUNCH_ORIGIN.y },
      stiffness: 0.02,
      damping: 0.2,
      render: { visible: false }
    });

    Composite.add(world, [launchBar, constraint]);

    // ===== レバーUI ロジック =====
    const leverTrack = document.getElementById('leverTrack');
    const leverKnob  = document.getElementById('leverKnob');
    const leverStrengthText = document.getElementById('leverStrength');

    const trackRect = () => leverTrack.getBoundingClientRect();

    let isDraggingLever = false;
    let leverStartY = 0;
    let knobStartTop = 0;

    // レバーの「0～1」の引き具合（0=上、1=一番下）
    let leverAmount = 0;

    function updateLeverKnobPositionFromAmount() {
      const rect = trackRect();
      const knobHeight = leverKnob.offsetHeight;
      const maxTravel = rect.height - knobHeight - 4; // 上下の余白分
      const top = 2 + maxTravel * leverAmount;
      leverKnob.style.top = top + 'px';
      leverStrengthText.textContent = '引き具合: ' + Math.round(leverAmount * 100) + '%';
    }

    // レバーをドラッグ開始
    function onLeverDown(event) {
      isDraggingLever = true;
      leverKnob.classList.add('dragging');

      const clientY = (event.touches ? event.touches[0] : event).clientY;
      leverStartY   = clientY;
      knobStartTop  = parseFloat(getComputedStyle(leverKnob).top || '2');
      event.preventDefault();
    }

    function onLeverMove(event) {
      if (!isDraggingLever) return;
      const clientY = (event.touches ? event.touches[0] : event).clientY;
      const dy = clientY - leverStartY;

      const rect = trackRect();
      const knobHeight = leverKnob.offsetHeight;
      const maxTravel = rect.height - knobHeight - 4;

      let newTop = knobStartTop + dy;
      newTop = Math.max(2, Math.min(2 + maxTravel, newTop));

      leverKnob.style.top = newTop + 'px';

      // 0～1 に正規化
      leverAmount = (newTop - 2) / maxTravel;
      leverStrengthText.textContent = '引き具合: ' + Math.round(leverAmount * 100) + '%';
    }

    // レバー離した瞬間 → 発射
    function onLeverUp() {
      if (!isDraggingLever) return;
      isDraggingLever = false;
      leverKnob.classList.remove('dragging');

      // 発射処理
      fireLaunchBar(leverAmount);

      // レバーをスプリングで戻るイメージ → ゆっくり0に戻す
      const startAmount = leverAmount;
      const duration = 200; // ms
      const startTime = performance.now();

      function animateBack(t) {
        const elapsed = t - startTime;
        const ratio = Math.min(1, elapsed / duration);
        const eased = 1 - Math.pow(1 - ratio, 3); // ちょっと滑らかなカーブ
        leverAmount = startAmount * (1 - eased);
        updateLeverKnobPositionFromAmount();
        if (ratio < 1) {
          requestAnimationFrame(animateBack);
        }
      }
      requestAnimationFrame(animateBack);
    }

    leverKnob.addEventListener('mousedown', onLeverDown);
    leverKnob.addEventListener('touchstart', onLeverDown, { passive: false });
    window.addEventListener('mousemove', onLeverMove);
    window.addEventListener('touchmove', onLeverMove, { passive: false });
    window.addEventListener('mouseup', onLeverUp);
    window.addEventListener('touchend', onLeverUp);
    window.addEventListener('touchcancel', onLeverUp);

    updateLeverKnobPositionFromAmount();

    // ===== 発射処理 =====
    // leverPower: 0～1
    function fireLaunchBar(leverPower) {
      if (leverPower <= 0.01) return; // ほとんど引いてなければ何もしない

      // 1. 発射棒を初期位置に戻し、速度0にリセット
      Body.setPosition(launchBar, { x: LAUNCH_ORIGIN.x, y: LAUNCH_ORIGIN.y });
      Body.setVelocity(launchBar, { x: 0, y: 0 });
      Body.setAngle(launchBar, 0);
      Body.setAngularVelocity(launchBar, 0);

      // 2. 発射範囲内のコインを探す（穴の周辺の矩形範囲）
      const RANGE_W = 120;
      const RANGE_H = 80;
      const rangeCenter = {
        x: LAUNCH_ORIGIN.x + 40,
        y: LAUNCH_ORIGIN.y
      };

      const targetCoins = coins.filter(c => {
        const pos = c.position;
        return (
          pos.x > rangeCenter.x - RANGE_W/2 &&
          pos.x < rangeCenter.x + RANGE_W/2 &&
          pos.y > rangeCenter.y - RANGE_H/2 &&
          pos.y < rangeCenter.y + RANGE_H/2
        );
      });

      // 棒の向き（基本は右向き）
      const direction = Vector.normalise({ x: 1, y: 0 });

      // 3. レバーの引き具合に応じて棒に初速度を与える
      const BASE_SPEED = 20; // ベースの速さ
      const speed = BASE_SPEED * leverPower;

      Body.applyForce(
        launchBar,
        { x: LAUNCH_ORIGIN.x, y: LAUNCH_ORIGIN.y },
        { x: direction.x * speed * 0.005, y: direction.y * speed * 0.005 }
      );

      // 4. コインにも同時にインパルスを与える（棒が当たる「勢い」を付ける）
      targetCoins.forEach(c => {
        Body.applyForce(
          c,
          c.position,
          { x: direction.x * speed * 0.003, y: direction.y * speed * 0.001 } // 少し上向きにも
        );
      });
    }

    // ===== UI: 10円追加・クリア・重力 =====
    document.getElementById('addCoinBtn').addEventListener('click', () => {
      // 左上あたりから斜め床に向かって転がるような位置に追加
      const x = 140 + (Math.random() * 40 - 20);
      const y = 80 + (Math.random() * 20 - 10);
      createCoin(x, y);
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      coins.forEach(c => Composite.remove(world, c));
      coins.length = 0;
    });

    document.getElementById('gravity').addEventListener('input', (e) => {
      const g = parseFloat(e.target.value) || 0;
      engine.world.gravity.y = g;
    });
  </script>
</body>
</html>
