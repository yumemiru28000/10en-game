<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>10円ゲーム (Matter.js / ren.png から自動生成)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; background:#111; color:#eee; font-family: sans-serif; }
    #wrap { display:flex; height:100vh; overflow:hidden; }
    #ui {
      width: 280px; padding: 10px; box-sizing:border-box;
      border-right: 1px solid #333; background:#0b0b0b;
      font-size: 12px;
    }
    #ui h1 { font-size: 14px; margin: 0 0 10px; }
    #ui .row { margin: 8px 0; }
    #ui .label { color:#bbb; font-size: 11px; }
    #ui button {
      background:#333; color:#eee; border:1px solid #555; border-radius:4px;
      padding: 6px 8px; cursor:pointer; font-size: 12px;
    }
    #ui button:hover { background:#444; }
    #ui input[type="number"]{
      width: 80px; background:#222; color:#eee; border:1px solid #555; border-radius:4px; padding:3px 6px;
    }
    #world { flex: 1; position: relative; }
    canvas { display:block; background:#000; }
    #hint { color:#9bd; line-height: 1.5; }
    #status { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 11px; color:#cfc; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="ui">
    <h1>10円ゲーム（自動生成）</h1>

    <div class="row" id="hint">
      ・入力: ren.png（黒=地形 / 赤=穴 / 緑=開始 / 黄=バネ）<br>
      ・操作: コインがバネ範囲内のとき、ドラッグで引いて離すと発射<br>
      ・目的: 穴に落ちないように転がす
    </div>

    <div class="row">
      <div class="label">コイン半径(px)</div>
      <input id="coinR" type="number" value="32" min="4" max="128">
    </div>

    <div class="row">
      <div class="label">重力（Matter）</div>
      <input id="gravityY" type="number" value="1" step="0.1" min="0" max="5">
    </div>

    <div class="row">
      <div class="label">最大発射速度</div>
      <input id="maxImpulse" type="number" value="18" step="1" min="1" max="80">
    </div>

    <div class="row">
      <div class="label">上方向バイアス</div>
      <input id="verticalBias" type="number" value="0.22" step="0.01" min="0" max="1">
    </div>

    <div class="row">
      <button id="reloadBtn">ren.png から再生成</button>
      <button id="respawnBtn">リスポーン</button>
    </div>

    <div class="row">
      <div class="label">状態</div>
      <div id="status">loading...</div>
    </div>

    <div class="row" style="color:#888">
      ※ index.html は線エディタのまま残しています。<br>
      game.html を開いてください。
    </div>
  </div>

  <div id="world"></div>
</div>

<!-- Matter.js -->
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>

<script>
(() => {
  const REN_URL = "ren.png";

  // --- 色判定（多少のブレ許容） ---
  // ※PNGのアンチエイリアス等があると境界で混色するので、閾値で判定します
  function classifyPixel(r,g,b,a){
    if (a < 10) return "empty";

    // 黒（壁/斜面）
    if (r < 40 && g < 40 && b < 40) return "black";

    // 赤（穴）
    if (r > 180 && g < 80 && b < 80) return "red";

    // 緑（開始）
    if (g > 160 && r < 120 && b < 120) return "green";

    // 黄（バネ）: (r,g高く b低め)
    if (r > 180 && g > 180 && b < 120) return "yellow";

    return "empty";
  }

  // 4近傍で連結成分抽出（塗り領域の島を取りたいので4近傍推奨）
  function extractComponents(mask, w, h){
    // mask[y*w+x] が true のピクセルを島に分割
    const visited = new Uint8Array(w*h);
    const comps = [];
    const qx = new Int32Array(w*h);
    const qy = new Int32Array(w*h);

    const idx = (x,y)=>y*w+x;
    const push = (x,y,tail)=>{
      qx[tail]=x; qy[tail]=y; return tail+1;
    };

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = idx(x,y);
        if (!mask[i] || visited[i]) continue;

        let head=0, tail=0;
        tail = push(x,y,tail);
        visited[i]=1;

        let sumX=0, sumY=0, area=0;
        let minX=x, minY=y, maxX=x, maxY=y;

        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++;
          area++;
          sumX += cx; sumY += cy;
          if (cx<minX) minX=cx; if (cy<minY) minY=cy;
          if (cx>maxX) maxX=cx; if (cy>maxY) maxY=cy;

          // 4-neighbors
          const n1 = (cx>0)   ? idx(cx-1,cy) : -1;
          const n2 = (cx<w-1) ? idx(cx+1,cy) : -1;
          const n3 = (cy>0)   ? idx(cx,cy-1) : -1;
          const n4 = (cy<h-1) ? idx(cx,cy+1) : -1;

          if (n1>=0 && mask[n1] && !visited[n1]){ visited[n1]=1; tail=push(cx-1,cy,tail); }
          if (n2>=0 && mask[n2] && !visited[n2]){ visited[n2]=1; tail=push(cx+1,cy,tail); }
          if (n3>=0 && mask[n3] && !visited[n3]){ visited[n3]=1; tail=push(cx,cy-1,tail); }
          if (n4>=0 && mask[n4] && !visited[n4]){ visited[n4]=1; tail=push(cx,cy+1,tail); }
        }

        const cx = sumX / area;
        const cy = sumY / area;
        comps.push({
          area,
          centroid: { x: cx, y: cy },
          aabb: { minX, minY, maxX, maxY }
        });
      }
    }

    // 面積が小さいノイズを落とす（必要なら調整）
    comps.sort((a,b)=>b.area-a.area);
    return comps;
  }

  // --- Configuration constants ---
  const EDGE_THICKNESS = 5;  // Thickness of terrain segments
  const RDP_EPSILON = 2.0;   // Simplification tolerance for RDP
  const MIN_SEG_LEN = 2;     // Minimum segment length to create
  const EDGE_CONNECT_TOLERANCE = 0.01;  // Distance tolerance for connecting edges
  const LOOP_CLOSURE_DISTANCE = 2;      // Max distance to close a polyline loop
  const LINE_DEGENERATE_EPSILON = 0.001; // Epsilon for degenerate line detection

  // --- Marching Squares: 輪郭抽出 ---
  // blackMask から境界の順序付きポリライン群を抽出
  function marchingSquares(mask, w, h) {
    const idx = (x,y) => y*w+x;
    
    // 各セルの4コーナーの状態からケースを決定 (0-15)
    // 時計回り: 左上、右上、右下、左下
    function getCase(x, y) {
      let val = 0;
      if (y > 0 && x > 0 && mask[idx(x-1, y-1)]) val |= 1;
      if (y > 0 && x < w && mask[idx(x, y-1)]) val |= 2;
      if (y < h && x < w && mask[idx(x, y)]) val |= 4;
      if (y < h && x > 0 && mask[idx(x-1, y)]) val |= 8;
      return val;
    }

    // エッジを抽出: 各セルケースに対応するエッジリスト
    // エッジは [x0,y0,x1,y1] で表現 (0.5刻みの座標)
    const edgeTable = {
      0: [], 15: [],
      1: [[0,0.5,0.5,0]], 2: [[0.5,0,1,0.5]], 4: [[0.5,1,1,0.5]], 8: [[0,0.5,0.5,1]],
      3: [[0,0.5,1,0.5]], 6: [[0.5,0,0.5,1]], 9: [[0.5,0,0.5,1]], 12: [[0,0.5,1,0.5]],
      5: [[0,0.5,0.5,1],[0.5,0,1,0.5]], 10: [[0,0.5,0.5,0],[0.5,1,1,0.5]],
      7: [[0.5,1,1,0.5]], 11: [[0.5,1,1,0.5]], 13: [[0.5,0,1,0.5]], 14: [[0,0.5,0.5,0]]
    };

    // 全エッジを収集
    const edges = [];
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const c = getCase(x, y);
        const es = edgeTable[c] || [];
        for (const [dx0,dy0,dx1,dy1] of es) {
          edges.push({
            x0: x + dx0, y0: y + dy0,
            x1: x + dx1, y1: y + dy1
          });
        }
      }
    }

    // エッジをポリラインに接続
    const polylines = [];
    const used = new Uint8Array(edges.length);
    
    for (let i = 0; i < edges.length; i++) {
      if (used[i]) continue;
      
      const poly = [{x: edges[i].x0, y: edges[i].y0}, {x: edges[i].x1, y: edges[i].y1}];
      used[i] = 1;
      
      // 末尾に接続可能なエッジを探す
      let changed = true;
      while (changed) {
        changed = false;
        const last = poly[poly.length - 1];
        
        for (let j = 0; j < edges.length; j++) {
          if (used[j]) continue;
          const e = edges[j];
          
          const d0 = Math.hypot(last.x - e.x0, last.y - e.y0);
          const d1 = Math.hypot(last.x - e.x1, last.y - e.y1);
          
          if (d0 < EDGE_CONNECT_TOLERANCE) {
            poly.push({x: e.x1, y: e.y1});
            used[j] = 1;
            changed = true;
            break;
          } else if (d1 < EDGE_CONNECT_TOLERANCE) {
            poly.push({x: e.x0, y: e.y0});
            used[j] = 1;
            changed = true;
            break;
          }
        }
      }
      
      // 先頭にも接続可能なエッジを探す
      changed = true;
      while (changed) {
        changed = false;
        const first = poly[0];
        
        for (let j = 0; j < edges.length; j++) {
          if (used[j]) continue;
          const e = edges[j];
          
          const d0 = Math.hypot(first.x - e.x0, first.y - e.y0);
          const d1 = Math.hypot(first.x - e.x1, first.y - e.y1);
          
          if (d0 < EDGE_CONNECT_TOLERANCE) {
            poly.unshift({x: e.x1, y: e.y1});
            used[j] = 1;
            changed = true;
            break;
          } else if (d1 < EDGE_CONNECT_TOLERANCE) {
            poly.unshift({x: e.x0, y: e.y0});
            used[j] = 1;
            changed = true;
            break;
          }
        }
      }
      
      if (poly.length >= 2) {
        polylines.push(poly);
      }
    }
    
    return polylines;
  }

  // --- Ramer-Douglas-Peucker: ポリライン簡略化 ---
  function simplifyPolylineRDP(points, epsilon) {
    if (points.length < 3) return points;
    
    // 始点と終点を結ぶ線分から最も遠い点を探す
    let maxDist = 0;
    let maxIndex = 0;
    const first = points[0];
    const last = points[points.length - 1];
    
    for (let i = 1; i < points.length - 1; i++) {
      const dist = perpendicularDistance(points[i], first, last);
      if (dist > maxDist) {
        maxDist = dist;
        maxIndex = i;
      }
    }
    
    // 閾値以上なら分割して再帰
    if (maxDist > epsilon) {
      const left = simplifyPolylineRDP(points.slice(0, maxIndex + 1), epsilon);
      const right = simplifyPolylineRDP(points.slice(maxIndex), epsilon);
      return left.slice(0, -1).concat(right);
    } else {
      return [first, last];
    }
  }
  
  function perpendicularDistance(point, lineStart, lineEnd) {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const norm = Math.hypot(dx, dy);
    if (norm < LINE_DEGENERATE_EPSILON) return Math.hypot(point.x - lineStart.x, point.y - lineStart.y);
    
    const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (norm * norm);
    const projX = lineStart.x + t * dx;
    const projY = lineStart.y + t * dy;
    
    return Math.hypot(point.x - projX, point.y - projY);
  }

  // Matter.js: 線分→薄い矩形ボディ（静的）
  function segmentToBody(Matter, seg, thickness=4, opt={}){
    const { Bodies } = Matter;
    const x1=seg.x1, y1=seg.y1, x2=seg.x2, y2=seg.y2;
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const dx=x2-x1, dy=y2-y1;
    const len=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx);
    return Bodies.rectangle(mx, my, len, thickness, {
      isStatic:true,
      friction: 0.9,
      restitution: 0,
      angle: ang,
      ...opt
    });
  }

  // --- ゲーム本体 ---
  const elWorld = document.getElementById("world");
  const statusEl = document.getElementById("status");
  const reloadBtn = document.getElementById("reloadBtn");
  const respawnBtn = document.getElementById("respawnBtn");

  const coinRInput = document.getElementById("coinR");
  const gravityYInput = document.getElementById("gravityY");
  const maxImpulseInput = document.getElementById("maxImpulse");
  const verticalBiasInput = document.getElementById("verticalBias");

  const Matter = window.Matter;
  const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

  let engine, render, runner;
  let renImage, renCanvas, renCtx, renData;
  let mapW=0, mapH=0;

  let coin=null;
  let spawnPoint={x:100,y:100};

  let holes=[];     // sensor circles
  let springs=[];   // { body(sensor), center, dir, cooldownUntil, aabb }

  let touchingGround = false;
  let lastGroundNormal = null;
  let postLaunchGraceUntil = 0; // Post-launch grace period to reduce collision artifacts

  // レバー（簡易）：画面上でドラッグしてパワー決定。対象バネは「範囲内で最も近いもの」
  let dragging=false;
  let dragStart=null;
  let dragNow=null;

  function setStatus(lines){
    statusEl.textContent = lines.join("\n");
  }

  function destroyWorld(){
    if (render) {
      Render.stop(render);
      render.canvas.remove();
      render.textures = {};
      render = null;
    }
    if (runner) { Runner.stop(runner); runner=null; }
    if (engine) { World.clear(engine.world, false); Engine.clear(engine); engine=null; }
    holes=[]; springs=[];
    coin=null;
  }

  async function loadRenPng(){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = REN_URL + "?t=" + Date.now();
    });
  }

  function buildRenImageData(img){
    mapW = img.naturalWidth || img.width;
    mapH = img.naturalHeight || img.height;

    renCanvas = document.createElement("canvas");
    renCanvas.width = mapW;
    renCanvas.height = mapH;
    renCtx = renCanvas.getContext("2d", { willReadFrequently:true });
    renCtx.drawImage(img, 0, 0);
    renData = renCtx.getImageData(0,0,mapW,mapH);
  }

  function buildMasks(){
    const w=mapW, h=mapH;
    const data=renData.data;
    const black = new Uint8Array(w*h);
    const red   = new Uint8Array(w*h);
    const green = new Uint8Array(w*h);
    const yellow= new Uint8Array(w*h);

    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = (y*w+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
        const c = classifyPixel(r,g,b,a);
        const p = y*w+x;
        if (c==="black") black[p]=1;
        else if (c==="red") red[p]=1;
        else if (c==="green") green[p]=1;
        else if (c==="yellow") yellow[p]=1;
      }
    }
    return {black, red, green, yellow};
  }

  function createEngineAndRenderer(){
    engine = Engine.create();
    engine.gravity.y = parseFloat(gravityYInput.value) || 1;

    render = Render.create({
      element: elWorld,
      engine,
      options: {
        width: mapW,
        height: mapH,
        wireframes: false,
        background: "#000",
        hasBounds: false
      }
    });

    runner = Runner.create();
    Render.run(render);
    Runner.run(runner, engine);
  }

  function addCoin(){
    const r = parseFloat(coinRInput.value) || 32;

    coin = Bodies.circle(spawnPoint.x, spawnPoint.y, r, {
      restitution: 0,
      friction: 0.05,
      frictionStatic: 0.85,
      frictionAir: 0.01,
      density: 0.005,
      render: {
        fillStyle: "#b87333", // 銅っぽい
        strokeStyle: "#5b2a12",
        lineWidth: 2
      }
    });

    World.add(engine.world, coin);
  }

  function respawn(){
    if (!coin) return;
    Body.setPosition(coin, {x:spawnPoint.x, y:spawnPoint.y});
    Body.setVelocity(coin, {x:0, y:0});
    Body.setAngularVelocity(coin, 0);
  }

  function addHolesFromComponents(redComps){
    holes = [];
    for (const c of redComps){
      // 面積→半径推定（円近似）
      const area = c.area;
      let r = Math.sqrt(area / Math.PI);
      r = Math.max(12, Math.min(90, r));

      const hole = Bodies.circle(c.centroid.x, c.centroid.y, r, {
        isStatic: true,
        isSensor: true,
        render: { fillStyle: "rgba(255,0,0,0.25)", strokeStyle: "rgba(255,0,0,0.7)", lineWidth: 1 }
      });
      hole.label = "hole";
      holes.push(hole);
    }
    World.add(engine.world, holes);
  }

  function addSpringsFromComponents(yellowComps){
    springs = [];
    const centerX = mapW / 2;

    // 6個想定：面積順で上位6だけ採用（ノイズ除去）
    const picked = yellowComps.slice(0, 6);

    for (const c of picked){
      const dir = (c.centroid.x < centerX) ? +1 : -1;
      const pad = 6;
      const aabb = {
        minX: c.aabb.minX - pad,
        minY: c.aabb.minY - pad,
        maxX: c.aabb.maxX + pad,
        maxY: c.aabb.maxY + pad,
      };

      // センサー矩形（コインが入ってるか判定用）
      const w = Math.max(10, aabb.maxX - aabb.minX);
      const h = Math.max(10, aabb.maxY - aabb.minY);
      const sensor = Bodies.rectangle(
        (aabb.minX+aabb.maxX)/2,
        (aabb.minY+aabb.maxY)/2,
        w, h,
        { isStatic:true, isSensor:true,
          render:{ fillStyle:"rgba(255,255,0,0.18)", strokeStyle:"rgba(255,255,0,0.6)", lineWidth:1 }
        }
      );
      sensor.label = "springSensor";

      springs.push({
        sensor,
        center: { x: c.centroid.x, y: c.centroid.y },
        dir,
        cooldownUntil: 0,
        aabb
      });
    }
    World.add(engine.world, springs.map(s=>s.sensor));
  }

  function addTerrainFromBlack(blackMask){
    // Marching Squares で輪郭抽出 → RDP で簡略化 → 線分ボディ化
    const polylines = marchingSquares(blackMask, mapW, mapH);
    
    const bodies = [];
    let totalSegments = 0;
    
    for (const poly of polylines) {
      // RDP で簡略化
      const simplified = simplifyPolylineRDP(poly, RDP_EPSILON);
      
      // 連続する点を線分ボディに変換
      for (let i = 0; i < simplified.length - 1; i++) {
        const p1 = simplified[i];
        const p2 = simplified[i + 1];
        
        const len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        if (len < MIN_SEG_LEN) continue; // 短すぎる線分はスキップ
        
        const seg = { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
        const b = segmentToBody(Matter, seg, EDGE_THICKNESS, {
          render: { fillStyle: "#222" }
        });
        b.label = "terrain";
        bodies.push(b);
        totalSegments++;
      }
      
      // 閉じたループの場合、最後と最初をつなぐ
      if (simplified.length >= 3) {
        const first = simplified[0];
        const last = simplified[simplified.length - 1];
        const dist = Math.hypot(last.x - first.x, last.y - first.y);
        if (dist < LOOP_CLOSURE_DISTANCE) { // 始点と終点が近ければループを閉じる
          const seg = { x1: last.x, y1: last.y, x2: first.x, y2: first.y };
          const b = segmentToBody(Matter, seg, EDGE_THICKNESS, {
            render: { fillStyle: "#222" }
          });
          b.label = "terrain";
          bodies.push(b);
          totalSegments++;
        }
      }
    }
    
    World.add(engine.world, bodies);
    return { polylineCount: polylines.length, segCount: totalSegments };
  }

  function findSpawnFromGreen(greenComps){
    if (greenComps.length === 0) return {x:100,y:100};
    // 一番大きい島
    return { x: greenComps[0].centroid.x, y: greenComps[0].centroid.y };
  }

  function currentTimeSec(){
    return performance.now() / 1000;
  }

  function coinInsideSpring(spring){
    const p = coin.position;
    const a = spring.aabb;
    return (p.x >= a.minX && p.x <= a.maxX && p.y >= a.minY && p.y <= a.maxY);
  }

  function nearestAvailableSpring(){
    let best=null, bestD2=Infinity;
    for (const s of springs){
      if (!coinInsideSpring(s)) continue;
      const dx = coin.position.x - s.center.x;
      const dy = coin.position.y - s.center.y;
      const d2 = dx*dx+dy*dy;
      if (d2 < bestD2) { bestD2=d2; best=s; }
    }
    return best;
  }

  function launchFromSpring(s, power01){
    const now = currentTimeSec();
    if (now < s.cooldownUntil) return;
    if (!touchingGround) return; // 空中発動禁止

    const maxImpulse = parseFloat(maxImpulseInput.value) || 18;
    const verticalBias = parseFloat(verticalBiasInput.value) || 0.22;

    const impulse = maxImpulse * Math.max(0, Math.min(1, power01));
    // 速度上書き（仕様通り）
    Body.setVelocity(coin, { x: s.dir * impulse, y: -impulse * verticalBias });
    Body.setAngularVelocity(coin, 0);

    // 0.3秒クールダウン + 50ms post-launch grace period
    s.cooldownUntil = now + 0.3;
    postLaunchGraceUntil = now + 0.05; // 50ms grace period
  }

  function installEvents(){
    // 接地判定・穴判定
    Events.on(engine, "collisionActive", (ev) => {
      touchingGround = false;
      lastGroundNormal = null;

      for (const pair of ev.pairs){
        const a = pair.bodyA, b = pair.bodyB;

        // hole
        if ((a === coin && b.label==="hole") || (b === coin && a.label==="hole")){
          // 落下
          respawn();
          continue;
        }

        // terrain contact
        const isTerrainContact =
          (a === coin && b.label==="terrain") || (b === coin && a.label==="terrain");
        if (isTerrainContact){
          touchingGround = true;
          // 接触法線（コイン側基準）
          // pair.collision.normal は bodyB→bodyA 方向だったりするので、符号は厳密じゃないが
          // 接線方向減衰の近似に使うだけなのでOK
          lastGroundNormal = pair.collision.normal;
        }
      }
    });

    // 緩い坂で止める（嘘静止摩擦）
    Events.on(engine, "afterUpdate", () => {
      if (!coin) return;

      // 状態表示
      const sp = coin.speed.toFixed(2);
      const av = coin.angularVelocity.toFixed(3);
      setStatus([
        `map: ${mapW}x${mapH}`,
        `coin: r=${(parseFloat(coinRInput.value)||32)} speed=${sp} angVel=${av}`,
        `touchingGround: ${touchingGround}`,
        `springs: ${springs.length}, holes: ${holes.length}`,
        dragging ? `drag: ${(Math.hypot(dragNow.x-dragStart.x, dragNow.y-dragStart.y)).toFixed(1)}px` : `drag: -`
      ]);

      // Skip ground friction during post-launch grace period
      const now = currentTimeSec();
      if (now < postLaunchGraceUntil) return;

      if (!touchingGround || !lastGroundNormal) return;

      // 接線方向 t を法線 n から作る
      const n = lastGroundNormal;
      const t = { x: -n.y, y: n.x };

      const v = coin.velocity;
      const vt = v.x*t.x + v.y*t.y;

      // 緩い坂判定：法線がほぼ上向き（=平坦に近い）なら止まりやすくする
      // nが(0,-1) 付近なら床、斜面が急になるほど |n.x| が増える想定
      const slopeMeasure = Math.abs(n.x); // 0に近いほど平坦

      // 速��が小さく、かつ斜面が緩いなら完全停止
      if (Math.abs(vt) < 0.15 && Math.abs(coin.angularVelocity) < 0.02 && slopeMeasure < 0.25){
        Body.setVelocity(coin, { x: 0, y: v.y }); // yは接触解決に任せる
        Body.setAngularVelocity(coin, 0);
      } else {
        // 接線方向だけ少し減衰（転がりの“気持ちよさ”＋微振動対策）
        const damp = (slopeMeasure < 0.25) ? 0.985 : 0.992;
        const vt2 = vt * damp;
        const dv = vt2 - vt;
        Body.setVelocity(coin, { x: v.x + t.x*dv, y: v.y + t.y*dv });
      }
    });

    // レバー（マウ���）
    const canvas = () => render && render.canvas;

    function getMousePos(e){
      const rect = canvas().getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function onDown(e){
      if (!coin) return;
      const s = nearestAvailableSpring();
      if (!s) return;

      dragging = true;
      dragStart = getMousePos(e);
      dragNow = {...dragStart};
    }

    function onMove(e){
      if (!dragging) return;
      dragNow = getMousePos(e);
    }

    function onUp(e){
      if (!dragging) return;
      dragging = false;

      const s = nearestAvailableSpring();
      if (!s) return;

      const dx = dragNow.x - dragStart.x;
      const dy = dragNow.y - dragStart.y;
      const dist = Math.hypot(dx,dy);

      const maxPull = 140; // 引ける最大距離（UIの感触）
      const power01 = Math.max(0, Math.min(1, dist / maxPull));
      launchFromSpring(s, power01);
    }

    // Render作成後にcanvasができるので、少し遅延して登録
    setTimeout(() => {
      if (!canvas()) return;
      canvas().addEventListener("mousedown", onDown);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp);
    }, 0);
  }

  async function rebuild(){
    destroyWorld();

    setStatus(["loading ren.png..."]);
    renImage = await loadRenPng();
    buildRenImageData(renImage);

    createEngineAndRenderer();

    // 背景として ren.png をそのまま表示（見た目は分離したいが、まずはデバッグ用）
    render.options.background = `url(${REN_URL})`;
    render.canvas.style.backgroundSize = "100% 100%";

    const {black, red, green, yellow} = buildMasks();

    const greenComps = extractComponents(green, mapW, mapH);
    const redComps = extractComponents(red, mapW, mapH);
    const yellowComps = extractComponents(yellow, mapW, mapH);

    spawnPoint = findSpawnFromGreen(greenComps);

    const terrainInfo = addTerrainFromBlack(black);

    addHolesFromComponents(redComps);
    addSpringsFromComponents(yellowComps);
    addCoin();

    installEvents();

    setStatus([
      `map: ${mapW}x${mapH}`,
      `spawn: (${spawnPoint.x.toFixed(1)}, ${spawnPoint.y.toFixed(1)})`,
      `terrain polylines=${terrainInfo.polylineCount} segs=${terrainInfo.segCount}`,
      `holes=${redComps.length} springs=${Math.min(6, yellowComps.length)}`,
      `ready`
    ]);
  }

  // UI
  reloadBtn.addEventListener("click", () => rebuild());
  respawnBtn.addEventListener("click", () => respawn());
  gravityYInput.addEventListener("change", () => { if(engine) engine.gravity.y = parseFloat(gravityYInput.value)||1; });

  // start
  rebuild().catch(err => {
    console.error(err);
    setStatus(["ERROR:", String(err)]);
  });
})();
</script>
</body>
</html>
