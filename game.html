<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>10円ゲーム</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #gameCanvas {
      display: block;
      image-rendering: pixelated;
    }
    #ui {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      color: #fff;
      font-size: 12px;
      font-family: sans-serif;
    }
    #resetBtn {
      background: #444;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 5px;
    }
    #resetBtn:hover { background: #666; }
    #status {
      margin-top: 8px;
      font-size: 10px;
      color: #aaa;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="ui">
    <div style="font-weight: bold;">10円ゲーム</div>
    <button id="resetBtn">リセット</button>
    <div id="status">読み込み中...</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  
  <script>
  (async () => {
    'use strict';
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const resetBtn = document.getElementById('resetBtn');
    
    // 設定
    const CONFIG = {
      coinRadius: 29,  // 10円硬貨の半径（ピクセル、視覚的サイズ調整済み）
      coinMass: 0.0055,  // 5.5g → kg
      gravity: 1.0,
      friction: 0.6,
      restitution: 0.1,
      leverMaxAngle: Math.PI / 2,  // 90度
      leverResistance: 0.4,  // バネの抵抗
    };
    
    let engine, world, coin, render;
    let mapImg, renImg, renData;
    let mapW, mapH;
    let spawnPoint = { x: 100, y: 100 };
    let springs = [];
    let holes = [];
    let walls = [];
    
    // レバー状態
    let activeLever = null;
    let leverStartAngle = 0;
    let leverCurrentAngle = 0;
    let leverPivot = null;
    
    // 画像読み込み
    async function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load ' + src));
        img.src = src + '?t=' + Date.now();
      });
    }
    
    // 色判定
    function getPixelType(r, g, b, a) {
      if (a < 10) return null;
      
      // 黒 = 壁
      if (r < 50 && g < 50 && b < 50) return 'wall';
      
      // 黄色 = 発射台
      if (r > 180 && g > 180 && b < 120) return 'spring';
      
      // 緑 = スポーン
      if (g > 150 && r < 120 && b < 120) return 'spawn';
      
      // 赤 = 穴
      if (r > 180 && g < 100 && b < 100) return 'hole';
      
      return null;
    }
    
    // ren.png解析
    function analyzeRenPng(img) {
      const w = img.width;
      const h = img.height;
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = w;
      tempCanvas.height = h;
      const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
      tempCtx.drawImage(img, 0, 0);
      const data = tempCtx.getImageData(0, 0, w, h);
      
      const wallPixels = [];
      const springPixels = [];
      const holePixels = [];
      let spawnX = 0, spawnY = 0, spawnCount = 0;
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          const type = getPixelType(data.data[i], data.data[i+1], data.data[i+2], data.data[i+3]);
          
          if (type === 'wall') wallPixels.push({x, y});
          else if (type === 'spring') springPixels.push({x, y});
          else if (type === 'hole') holePixels.push({x, y});
          else if (type === 'spawn') {
            spawnX += x;
            spawnY += y;
            spawnCount++;
          }
        }
      }
      
      if (spawnCount > 0) {
        spawnPoint = { x: spawnX / spawnCount, y: spawnY / spawnCount };
      }
      
      return {
        width: w,
        height: h,
        wallPixels,
        springRegions: clusterPixels(springPixels, w, h),
        holeRegions: clusterPixels(holePixels, w, h),
        spawn: spawnPoint
      };
    }
    
    // ピクセルをクラスタリング
    function clusterPixels(pixels, w, h) {
      if (pixels.length === 0) return [];
      
      const visited = new Set();
      const regions = [];
      
      for (const pixel of pixels) {
        const key = `${pixel.x},${pixel.y}`;
        if (visited.has(key)) continue;
        
        const region = [];
        const queue = [pixel];
        visited.add(key);
        
        while (queue.length > 0) {
          const p = queue.shift();
          region.push(p);
          
          // 4近傍
          const neighbors = [
            {x: p.x-1, y: p.y}, {x: p.x+1, y: p.y},
            {x: p.x, y: p.y-1}, {x: p.x, y: p.y+1}
          ];
          
          for (const n of neighbors) {
            const nKey = `${n.x},${n.y}`;
            if (visited.has(nKey)) continue;
            if (pixels.some(pp => pp.x === n.x && pp.y === n.y)) {
              visited.add(nKey);
              queue.push(n);
            }
          }
        }
        
        if (region.length > 10) {
          const sumX = region.reduce((s, p) => s + p.x, 0);
          const sumY = region.reduce((s, p) => s + p.y, 0);
          const minX = Math.min(...region.map(p => p.x));
          const maxX = Math.max(...region.map(p => p.x));
          const minY = Math.min(...region.map(p => p.y));
          const maxY = Math.max(...region.map(p => p.y));
          
          regions.push({
            center: { x: sumX / region.length, y: sumY / region.length },
            bounds: { minX, maxX, minY, maxY },
            area: region.length
          });
        }
      }
      
      return regions.sort((a, b) => b.area - a.area);
    }
    
    // Matter.js初期化
    function initPhysics() {
      const { Engine, World, Bodies } = Matter;
      
      engine = Engine.create();
      engine.gravity.y = CONFIG.gravity;
      world = engine.world;
      
      // 壁生成（簡易版：境界ピクセルから線分作成）
      const boundaryPixels = findBoundaryPixels(renData.wallPixels, mapW, mapH);
      
      // グリッド分割して線分化
      for (let i = 0; i < boundaryPixels.length; i += 5) {
        if (i + 1 >= boundaryPixels.length) break;
        
        const p1 = boundaryPixels[i];
        const p2 = boundaryPixels[i + 1];
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const length = Math.sqrt(dx*dx + dy*dy);
        
        if (length < 2 || length > 50) continue;
        
        const angle = Math.atan2(dy, dx);
        const cx = (p1.x + p2.x) / 2;
        const cy = (p1.y + p2.y) / 2;
        
        const wall = Bodies.rectangle(cx, cy, length, 8, {
          isStatic: true,
          angle: angle,
          friction: CONFIG.friction,
          render: { visible: false }
        });
        wall.label = 'wall';
        World.add(world, wall);
        walls.push(wall);
      }
      
      // 発射台生成
      springs = [];
      const centerX = mapW / 2;
      
      for (const region of renData.springRegions.slice(0, 6)) {
        const isRight = region.center.x > centerX;
        const direction = isRight ? -1 : 1;  // 右側→左へ、左側→右へ
        
        springs.push({
          center: region.center,
          bounds: region.bounds,
          direction: direction,
          isRight: isRight
        });
      }
      
      // 穴生成
      holes = [];
      for (const region of renData.holeRegions) {
        const radius = Math.sqrt(region.area / Math.PI) * 0.8;
        const hole = Bodies.circle(region.center.x, region.center.y, radius, {
          isStatic: true,
          isSensor: true,
          render: { visible: false }
        });
        hole.label = 'hole';
        World.add(world, hole);
        holes.push({ body: hole, center: region.center, radius });
      }
      
      // コイン生成
      createCoin();
    }
    
    // 境界ピクセル検出
    function findBoundaryPixels(wallPixels, w, h) {
      const wallSet = new Set(wallPixels.map(p => `${p.x},${p.y}`));
      const boundary = [];
      
      for (const p of wallPixels) {
        // 4近傍に空きがあれば境界
        const neighbors = [
          `${p.x-1},${p.y}`, `${p.x+1},${p.y}`,
          `${p.x},${p.y-1}`, `${p.x},${p.y+1}`
        ];
        
        if (neighbors.some(n => !wallSet.has(n))) {
          boundary.push(p);
        }
      }
      
      return boundary;
    }
    
    // コイン生成
    function createCoin() {
      const { Bodies, World } = Matter;
      
      if (coin) World.remove(world, coin);
      
      coin = Bodies.circle(spawnPoint.x, spawnPoint.y, CONFIG.coinRadius, {
        density: CONFIG.coinMass / (Math.PI * CONFIG.coinRadius * CONFIG.coinRadius),
        friction: CONFIG.friction,
        frictionStatic: 1.0,
        frictionAir: 0.01,
        restitution: CONFIG.restitution,
        render: { visible: false }
      });
      coin.label = 'coin';
      
      World.add(world, coin);
    }
    
    // レバー開始
    function startLever(x, y) {
      if (!coin) return;
      
      // コインが発射台上にあるか確認
      for (const spring of springs) {
        const b = spring.bounds;
        if (coin.position.x >= b.minX - 10 && coin.position.x <= b.maxX + 10 &&
            coin.position.y >= b.minY - 10 && coin.position.y <= b.maxY + 10) {
          
          // レバーの中心点（発射台の逆側）
          leverPivot = {
            x: spring.isRight ? b.minX - 60 : b.maxX + 60,
            y: spring.center.y
          };
          
          leverStartAngle = Math.atan2(y - leverPivot.y, x - leverPivot.x);
          leverCurrentAngle = leverStartAngle;
          activeLever = spring;
          break;
        }
      }
    }
    
    // レバー移動
    function moveLever(x, y) {
      if (!activeLever || !leverPivot) return;
      
      const angle = Math.atan2(y - leverPivot.y, x - leverPivot.x);
      let deltaAngle = angle - leverStartAngle;
      
      // 時計回りに0-90度制限
      if (activeLever.isRight) {
        // 右側：下向きから時計回り
        deltaAngle = Math.max(0, Math.min(CONFIG.leverMaxAngle, deltaAngle));
      } else {
        // 左側：下向きから反時計回り
        deltaAngle = Math.max(-CONFIG.leverMaxAngle, Math.min(0, deltaAngle));
      }
      
      leverCurrentAngle = leverStartAngle + deltaAngle;
    }
    
    // レバー離す（発射）
    function releaseLever() {
      if (!activeLever || !leverPivot || !coin) {
        activeLever = null;
        leverPivot = null;
        return;
      }
      
      let pullAngle = Math.abs(leverCurrentAngle - leverStartAngle);
      
      // バネ抵抗を考慮した力計算
      const t = pullAngle / CONFIG.leverMaxAngle;
      const power = t * t * 30;  // 二次関数でバネの抵抗を表現
      
      // 発射方向（水平+少し上向き）
      const launchAngle = activeLever.direction > 0 ? -0.2 : Math.PI + 0.2;
      const vx = Math.cos(launchAngle) * power;
      const vy = Math.sin(launchAngle) * power;
      
      Matter.Body.setVelocity(coin, { x: vx, y: vy });
      
      activeLever = null;
      leverPivot = null;
    }
    
    // 描画
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // map.png背景
      ctx.drawImage(mapImg, 0, 0, mapW, mapH);
      
      // コイン描画
      if (coin) {
        ctx.save();
        ctx.translate(coin.position.x, coin.position.y);
        ctx.rotate(coin.angle);
        
        // 銅色の円
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, CONFIG.coinRadius);
        grad.addColorStop(0, '#cd7f32');
        grad.addColorStop(0.7, '#b87333');
        grad.addColorStop(1, '#8b5a3c');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, CONFIG.coinRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // 縁
        ctx.strokeStyle = '#5d3a1a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // "10"文字
        ctx.fillStyle = '#5d3a1a';
        ctx.font = 'bold 24px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('10', 0, -3);
        
        ctx.font = '10px serif';
        ctx.fillText('円', 0, 12);
        
        ctx.restore();
      }
      
      // レバー描画
      if (activeLever && leverPivot) {
        const leverLength = 80;
        const endX = leverPivot.x + Math.cos(leverCurrentAngle) * leverLength;
        const endY = leverPivot.y + Math.sin(leverCurrentAngle) * leverLength;
        
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(leverPivot.x, leverPivot.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // ピボット
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(leverPivot.x, leverPivot.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // メインループ
    function update() {
      Matter.Engine.update(engine, 1000 / 60);
      
      // 穴との衝突判定
      if (coin) {
        for (const hole of holes) {
          const dx = coin.position.x - hole.center.x;
          const dy = coin.position.y - hole.center.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < hole.radius + CONFIG.coinRadius * 0.5) {
            setTimeout(() => {
              Matter.Body.setPosition(coin, spawnPoint);
              Matter.Body.setVelocity(coin, { x: 0, y: 0 });
              Matter.Body.setAngularVelocity(coin, 0);
            }, 100);
            break;
          }
        }
        
        // ステータス更新
        const speed = Math.sqrt(coin.velocity.x**2 + coin.velocity.y**2);
        statusEl.textContent = `速度: ${speed.toFixed(1)}\n位置: ${coin.position.x.toFixed(0)}, ${coin.position.y.toFixed(0)}`;
      }
      
      draw();
      requestAnimationFrame(update);
    }
    
    // イベント
    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      startLever(e.clientX - rect.left, e.clientY - rect.top);
    });
    
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      moveLever(e.clientX - rect.left, e.clientY - rect.top);
    });
    
    canvas.addEventListener('mouseup', () => releaseLever());
    
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      startLever(touch.clientX - rect.left, touch.clientY - rect.top);
    }, { passive: false });
    
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      moveLever(touch.clientX - rect.left, touch.clientY - rect.top);
    }, { passive: false });
    
    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      releaseLever();
    }, { passive: false });
    
    resetBtn.addEventListener('click', () => {
      if (coin) {
        Matter.Body.setPosition(coin, spawnPoint);
        Matter.Body.setVelocity(coin, { x: 0, y: 0 });
        Matter.Body.setAngularVelocity(coin, 0);
      }
    });
    
    // 初期化
    try {
      statusEl.textContent = '画像読み込み中...';
      
      [mapImg, renImg] = await Promise.all([
        loadImage('map.png'),
        loadImage('ren.png')
      ]);
      
      mapW = renImg.width;
      mapH = renImg.height;
      
      canvas.width = mapW;
      canvas.height = mapH;
      
      statusEl.textContent = '物理構造解析中...';
      renData = analyzeRenPng(renImg);
      
      statusEl.textContent = '物理エンジン初期化中...';
      initPhysics();
      
      statusEl.textContent = '準備完了！';
      
      update();
      
    } catch (error) {
      console.error('Error:', error);
      statusEl.textContent = 'エラー: ' + error.message;
    }
  })();
  </script>
</body>
</html>
